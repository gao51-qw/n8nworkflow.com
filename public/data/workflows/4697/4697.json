{
  "workflow": {
    "id": 4697,
    "name": "Segment PDFs by table of contents with Gemini AI and Chunkr.ai",
    "views": 590,
    "recentViews": 0,
    "totalViews": 590,
    "createdAt": "2025-06-05T15:46:55.497Z",
    "description": "## Intelligently Segment PDFs by Table of Contents\n\nThis workflow empowers you to automatically process PDF documents, intelligently identify or generate a hierarchical Table of Contents (ToC), and then segment the entire document's content based on these ToC headings. It effectively breaks down a large PDF into its constituent sections, each paired with its corresponding heading and hierarchical level.\n\n### Why It's Useful\n\nUnlock the true structure of your PDFs for granular access and advanced processing:\n\n* **AI Agent Tool:** A key use case is to provide this workflow as a tool to an AI agent. The agent can then use the segmented output to \"read\" and navigate to specific sections of a document to answer questions, extract information, or perform tasks with much greater accuracy and efficiency.\n* **Targeted Content Extraction:** Programmatically pull out specific chapters or subsections for focused analysis, summarization, reporting, or repurposing content.\n* **Enhanced RAG Systems:** Improve your Retrieval Augmented Generation (RAG) pipelines by feeding them well-defined, contextually relevant document sections instead of entire, monolithic PDFs. This leads to more precise AI-generated responses.\n* **Modular Document Processing:** Process different parts of a document using distinct logic in subsequent n8n workflows by acting on individual sections.\n* **Data Preparation:** Seamlessly convert lengthy PDFs into a structured format where each section (including its heading, level, and content in multiple formats) becomes a distinct, manageable item.\n\n### How It Works\n\n1.  **Ingestion & Advanced Parsing:** The workflow ingests a PDF (via a provided URL or a pre-set one for manual runs). It then utilizes **Chunkr.ai** to perform Optical Character Recognition (OCR) and parse the document into detailed structural elements, extracting text, HTML, and Markdown for each segment.\n2.  **AI-Powered Table of Contents Generation:** A **Google Gemini** AI model analyzes the initial pages of the document (where a ToC often resides) along with section headers extracted by Chunkr as a fallback. This allows it to construct an accurate, hierarchical Table of Contents in a structured JSON format, even if the PDF lacks an explicit ToC or if it's poorly formatted.\n3.  **Precise Content Segmentation:** Sophisticated custom code then meticulously maps the AI-generated ToC headings to their corresponding content within the parsed document from Chunkr. It intelligently determines the precise start and end of each section.\n4.  **Structured & Flexible Output:**\n    * The primary output provides each identified section as an individual n8n item. Each item includes the heading text, its hierarchical level (e.g., 1, 1.1, 2), and the full content of that section in Text, HTML, and Markdown formats.\n    * Optionally, the workflow can also reconstruct the entire document into a single, navigable HTML file or a clean Markdown file.\n\n### What You Need\n\nTo run this workflow, you'll need:\n\n* **Input PDF:**\n    * When triggered by another workflow: A `URL` pointing to the PDF document.\n    * When triggered manually: The workflow uses a pre-configured sample PDF from Google Drive for demonstration (this can be customized).\n* **Chunkr.ai API Key:** Required for the initial parsing and OCR of the PDF document. You'll need to insert this into the relevant HTTP Request nodes.\n* **Google Gemini API Credentials:** Necessary for the AI model to intelligently generate the Table of Contents. This should be configured in the Google Gemini Chat Model nodes.\n\n### Outputs\n\nThe workflow primarily generates:\n\n* **Individual Document Sections:** A series of n8n items. Each item represents a distinct section of the PDF and contains:\n    * `heading`: The text of the section heading.\n    * `headingLevel`: The hierarchical level of the heading (e.g., 1 for H1, 2 for H2).\n    * `sectionText`: The plain text content of the section.\n    * `sectionHTML`: The HTML content of the section.\n    * `sectionMarkdown`: The Markdown content of the section.\n\nAlternatively, you can configure the workflow to output:\n\n* **Full Reconstructed Document:**\n    * A single HTML file representing the entire processed document.\n    * A single Markdown file representing the entire processed document.\n\nThis workflow is ideal for anyone looking to deconstruct PDFs into meaningful, manageable parts for advanced automation, AI integration, or detailed content analysis.",
    "workflow": {
      "meta": {
        "instanceId": "4970c3bf8a443f2d4c35b388ef96894f5ae52e32fa83fc8da098b824d939fbd9",
        "templateCredsSetupCompleted": true
      },
      "nodes": [
        {
          "id": "08ae2ea6-5ad1-4fdf-ac75-4e22811437cc",
          "name": "When clicking â€˜Execute workflowâ€™",
          "type": "n8n-nodes-base.manualTrigger",
          "disabled": true,
          "position": [
            -1860,
            -220
          ],
          "parameters": {},
          "typeVersion": 1
        },
        {
          "id": "f81acfdb-2eae-4824-a4ec-2540ff15fa12",
          "name": "Status is:",
          "type": "n8n-nodes-base.switch",
          "position": [
            -40,
            20
          ],
          "parameters": {
            "rules": {
              "values": [
                {
                  "outputKey": "Succeeded",
                  "conditions": {
                    "options": {
                      "version": 2,
                      "leftValue": "",
                      "caseSensitive": true,
                      "typeValidation": "strict"
                    },
                    "combinator": "and",
                    "conditions": [
                      {
                        "id": "a11576d1-4bfa-46ce-abce-25be2bc75a20",
                        "operator": {
                          "type": "string",
                          "operation": "equals"
                        },
                        "leftValue": "={{ $json.status }}",
                        "rightValue": "Succeeded"
                      }
                    ]
                  },
                  "renameOutput": true
                },
                {
                  "outputKey": "Processing",
                  "conditions": {
                    "options": {
                      "version": 2,
                      "leftValue": "",
                      "caseSensitive": true,
                      "typeValidation": "strict"
                    },
                    "combinator": "and",
                    "conditions": [
                      {
                        "id": "19b80bb6-63f5-47f7-9d58-321de4f6893c",
                        "operator": {
                          "name": "filter.operator.equals",
                          "type": "string",
                          "operation": "equals"
                        },
                        "leftValue": "={{ $json.status }}",
                        "rightValue": "Processing"
                      }
                    ]
                  },
                  "renameOutput": true
                },
                {
                  "outputKey": "Failed",
                  "conditions": {
                    "options": {
                      "version": 2,
                      "leftValue": "",
                      "caseSensitive": true,
                      "typeValidation": "strict"
                    },
                    "combinator": "and",
                    "conditions": [
                      {
                        "id": "b8822d01-57d4-47fd-95e9-5255ac5059f4",
                        "operator": {
                          "name": "filter.operator.equals",
                          "type": "string",
                          "operation": "equals"
                        },
                        "leftValue": "={{ $json.status }}",
                        "rightValue": "Failed"
                      }
                    ]
                  },
                  "renameOutput": true
                }
              ]
            },
            "options": {}
          },
          "typeVersion": 3.2
        },
        {
          "id": "77949b9c-b3a1-4cd9-b643-d7f49dc64726",
          "name": "Google Gemini Chat Model",
          "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
          "position": [
            1360,
            80
          ],
          "parameters": {
            "options": {},
            "modelName": "models/gemini-2.5-pro-preview-05-06"
          },
          "credentials": {
            "googlePalmApi": {
              "id": "credential-id",
              "name": "googlePalmApi Credential"
            }
          },
          "typeVersion": 1
        },
        {
          "id": "1e53fcc8-4697-48c4-90cb-c07dee049949",
          "name": "Structured Output Parser",
          "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
          "position": [
            1620,
            280
          ],
          "parameters": {
            "schemaType": "manual",
            "inputSchema": "{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"TableOfContents\",\n  \"description\": \"A JSON schema for representing a hierarchical table of contents with manually inlined nesting (up to 3 levels) to avoid $ref or $defs, and simplified keywords.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"tableOfContents\": {\n      \"type\": \"array\",\n      \"description\": \"The root list of top-level headings (Level 1).\",\n      \"items\": {\n        \"type\": \"object\",\n        \"description\": \"Represents a Level 1 heading.\",\n        \"properties\": {\n          \"text\": {\n            \"type\": \"string\",\n            \"description\": \"The text content of the Level 1 heading.\"\n          },\n          \"level\": {\n            \"type\": \"integer\",\n            \"description\": \"The hierarchical level of the heading (e.g., 1 for H1, 2 for H2, etc.).\"\n          },\n          \"children\": {\n            \"type\": \"array\",\n            \"description\": \"An array of Level 2 subheadings.\",\n            \"items\": {\n              \"type\": \"object\",\n              \"description\": \"Represents a Level 2 heading.\",\n              \"properties\": {\n                \"text\": {\n                  \"type\": \"string\",\n                  \"description\": \"The text content of the Level 2 heading.\"\n                },\n                \"level\": {\n                  \"type\": \"integer\",\n                  \"description\": \"The hierarchical level of the heading.\"\n                },\n                \"children\": {\n                  \"type\": \"array\",\n                  \"description\": \"An array of Level 3 subheadings.\",\n                  \"items\": {\n                    \"type\": \"object\",\n                    \"description\": \"Represents a Level 3 heading.\",\n                    \"properties\": {\n                      \"text\": {\n                        \"type\": \"string\",\n                        \"description\": \"The text content of the Level 3 heading.\"\n                      },\n                      \"level\": {\n                        \"type\": \"integer\",\n                        \"description\": \"The hierarchical level of the heading.\"\n                      },\n                      \"children\": {\n                        \"type\": \"array\",\n                        \"description\": \"Level 3 headings typically have no children in this model, but the array must exist.\",\n                        \"items\": {\n                          \"type\": \"object\",\n                          \"description\": \"Schema for items (if any, typically none) in the children array of a Level 3 heading. These items must be objects.\",\n                          \"additionalProperties\": false\n                        }\n                      }\n                    },\n                    \"required\": [\n                      \"text\",\n                      \"level\",\n                      \"children\"\n                    ],\n                    \"additionalProperties\": false\n                  }\n                }\n              },\n              \"required\": [\n                \"text\",\n                \"level\",\n                \"children\"\n              ],\n              \"additionalProperties\": false\n            }\n          }\n        },\n        \"required\": [\n          \"text\",\n          \"level\",\n          \"children\"\n        ],\n        \"additionalProperties\": false\n      }\n    }\n  },\n  \"required\": [\n    \"tableOfContents\"\n  ],\n  \"additionalProperties\": false\n}\n"
          },
          "typeVersion": 1.2
        },
        {
          "id": "ecccb5bf-6625-476e-b010-e50e3b89a80b",
          "name": "Auto-fixing Output Parser",
          "type": "@n8n/n8n-nodes-langchain.outputParserAutofixing",
          "position": [
            1480,
            80
          ],
          "parameters": {
            "options": {}
          },
          "typeVersion": 1
        },
        {
          "id": "97b36f68-cd64-437b-8af0-dada28b40ea8",
          "name": "Set File Name",
          "type": "n8n-nodes-base.set",
          "position": [
            -980,
            20
          ],
          "parameters": {
            "options": {},
            "assignments": {
              "assignments": [
                {
                  "id": "49f89680-ba63-43f1-af72-7e5afd8ecb0e",
                  "name": "fileName",
                  "type": "string",
                  "value": "={{ $('Merge').item.binary.data.fileName.replaceAll('.pdf','') }}"
                },
                {
                  "id": "646e8985-5587-41f6-b4b2-d781ecff9e7c",
                  "name": "fileNameSnake",
                  "type": "string",
                  "value": "={{ $('Merge').item.binary.data.fileName.replaceAll('.pdf','').toSnakeCase() }}"
                },
                {
                  "id": "a7eafca2-13e6-46d1-b281-2ef4ea4d6a93",
                  "name": "createdAt",
                  "type": "string",
                  "value": "={{ $now }}"
                }
              ]
            }
          },
          "typeVersion": 3.4
        },
        {
          "id": "46c53d9b-9387-4415-9b8c-b01a12e391a3",
          "name": "When Executed by Another Workflow",
          "type": "n8n-nodes-base.executeWorkflowTrigger",
          "position": [
            -1860,
            300
          ],
          "parameters": {
            "workflowInputs": {
              "values": [
                {
                  "name": "URL"
                }
              ]
            }
          },
          "typeVersion": 1.1
        },
        {
          "id": "f2145258-4cb1-4339-81d4-f9dfe524b972",
          "name": "Extract Sections headers as fallback",
          "type": "n8n-nodes-base.code",
          "position": [
            880,
            -180
          ],
          "parameters": {
            "jsCode": "// Input: Full JSON from Chunkr task\nconst chunks = $(\"Status is:\").first().json.output.chunks;\nconst headings = [];\n\nfor (const chunk of chunks) {\n  for (const segment of chunk.segments) {\n    if (segment.segment_type === 'SectionHeader') {\n      // We store the content of the heading\n      headings.push(segment.content.trim());\n    }\n  }\n}\n\n// Remove duplicates that might span chunks\nconst uniqueHeadings = [...new Set(headings)];\n\n// Return the ordered list of unique headings\nreturn [{ json: { headings: uniqueHeadings } }];"
          },
          "typeVersion": 2
        },
        {
          "id": "47b749ec-4832-45a0-826e-13ef23fd4647",
          "name": "Take beginning of Document to look for Table of contents",
          "type": "n8n-nodes-base.code",
          "position": [
            280,
            -180
          ],
          "parameters": {
            "jsCode": "\nconst taskResult = $input.first().json;\n\n\n\n// Define how many chunks you want to extract\nconst numberOfChunksToExtract = 10;\n\n// An array to hold the text content from the selected chunks\nlet textContentArray = [];\n\n// Check if the output and chunks exist in the task result\nif (taskResult.output && taskResult.output.chunks) {\n  const allChunks = taskResult.output.chunks;\n\n  // Loop through the first 'numberOfChunksToExtract' chunks,\n  // or fewer if the document doesn't have that many.\n  for (let i = 0; i < Math.min(numberOfChunksToExtract, allChunks.length); i++) {\n    const chunk = allChunks[i];\n    // Ensure the chunk and its 'embed' field exist and are not empty\n    if (chunk && chunk.embed && chunk.embed.trim() !== '') {\n      textContentArray.push(chunk.embed);\n    }\n  }\n}\n\n// Join all the collected text content with a double newline for separation\nconst concatenatedText = textContentArray.join('\\n\\n');\n\n// Return a single JSON object with the specified key and the concatenated text\nreturn [{\n  json: {\n    \"firstXNumberOfChunks\": concatenatedText\n  }\n}];"
          },
          "typeVersion": 2
        },
        {
          "id": "7f136d22-2195-4d56-803a-a9f6384f3557",
          "name": "Stop and Error",
          "type": "n8n-nodes-base.stopAndError",
          "position": [
            200,
            220
          ],
          "parameters": {
            "errorMessage": "The chunkr Task failed!"
          },
          "typeVersion": 1
        },
        {
          "id": "228fed4c-c2a9-4dde-a270-e674ae61b9da",
          "name": "Google Gemini Chat Model1",
          "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
          "position": [
            1500,
            280
          ],
          "parameters": {
            "options": {},
            "modelName": "models/gemini-2.5-flash-preview-05-20"
          },
          "credentials": {
            "googlePalmApi": {
              "id": "credential-id",
              "name": "googlePalmApi Credential"
            }
          },
          "typeVersion": 1
        },
        {
          "id": "9a21bf6c-208f-45a7-bb78-f27935b53b5d",
          "name": "Sticky Note",
          "type": "n8n-nodes-base.stickyNote",
          "position": [
            -2640,
            -240
          ],
          "parameters": {
            "width": 580,
            "height": 260,
            "content": "### Welcome to the Document Processing Workflow!\n\nThis workflow automates the extraction and structuring of content from PDF documents. It leverages Chunkr.ai for document parsing and an AI Agent to build a comprehensive Table of Contents.\n\n**To get started, you need a Chunkr.ai API Key.**\n1.  Go to [Chunkr AI](https://chunkr.ai)\n2.  Click \"Login\" and create your account.\n3.  Once logged in, navigate to \"API Keys\" in your dashboard to generate your key."
          },
          "typeVersion": 1
        },
        {
          "id": "447c7ec5-a094-4034-afc4-fcd7aae5f4de",
          "name": "Convert the PDF to base64",
          "type": "n8n-nodes-base.extractFromFile",
          "position": [
            -1180,
            20
          ],
          "parameters": {
            "options": {},
            "operation": "binaryToPropery",
            "binaryPropertyName": "=data"
          },
          "typeVersion": 1
        },
        {
          "id": "dfc84ad3-4a85-4641-bc16-1f89c54b1c3a",
          "name": "Sticky Note1",
          "type": "n8n-nodes-base.stickyNote",
          "position": [
            -1940,
            -460
          ],
          "parameters": {
            "width": 480,
            "height": 440,
            "content": "### Node: When clicking â€˜Execute workflowâ€™ (Manual Trigger)\n\nThis node allows you to manually start the workflow.\n\n**How to use:**\n1.  Simply click the \"Execute workflow\" button in the n8n interface.\n2.  When triggered manually, the workflow will automatically download a predefined PDF from Google Drive for processing."
          },
          "typeVersion": 1
        },
        {
          "id": "b61a3d2e-9773-4e03-ad49-380fca4bb04d",
          "name": "Sticky Note2",
          "type": "n8n-nodes-base.stickyNote",
          "position": [
            -1940,
            20
          ],
          "parameters": {
            "width": 480,
            "height": 460,
            "content": "### Node: When Executed by Another Workflow (Webhook Trigger)\n\nThis node allows external workflows to trigger this process.\n\n**How to use:**\n1.  Ensure the connected workflow provides a `URL` variable in its input. This `URL` should point to the PDF document you wish to process.\n2.  The workflow will then download the PDF from the provided URL.\n\n"
          },
          "typeVersion": 1
        },
        {
          "id": "0f1ddb9a-dc65-44b7-b5ed-b4f9fa64e743",
          "name": "Download PDF from URL",
          "type": "n8n-nodes-base.httpRequest",
          "position": [
            -1620,
            300
          ],
          "parameters": {
            "url": "={{ $json.URL }}",
            "options": {}
          },
          "typeVersion": 4.2
        },
        {
          "id": "b1095619-41f5-4381-9516-3c221ef98388",
          "name": "Download PDF from Google Drive",
          "type": "n8n-nodes-base.googleDrive",
          "disabled": true,
          "position": [
            -1640,
            -220
          ],
          "parameters": {
            "fileId": {
              "__rl": true,
              "mode": "list",
              "value": "11ReFvvEnHKiFegKJ5tjm-MMfJn96nBng",
              "cachedResultUrl": "https://drive.google.com/file/d/11ReFvvEnHKiFegKJ5tjm-MMfJn96nBng/view?usp=drivesdk",
              "cachedResultName": "S1-Handlungsempfehlung: Diagnostik und Therapie der Loiasis (Afrikanischer Augenwurm).pdf"
            },
            "options": {},
            "operation": "download"
          },
          "credentials": {
            "googleDriveOAuth2Api": {
              "id": "credential-id",
              "name": "googleDriveOAuth2Api Credential"
            }
          },
          "typeVersion": 3
        },
        {
          "id": "ceb2c044-a55c-4c9d-9736-6769cce0ed12",
          "name": "Sticky Note3",
          "type": "n8n-nodes-base.stickyNote",
          "position": [
            -1100,
            -500
          ],
          "parameters": {
            "width": 1000,
            "height": 400,
            "content": "### Node: POST Chunkr Task (HTTP Request) & GET Chunkr task\n\n### ðŸš¨ðŸš¨ðŸš¨ INSERT A CHUNKR.AI API KEY HERE\n\n\nThis node sends your document to Chunkr.ai for processing.\n\n**How to use:**\n1.  **Authorization:** Replace <your_api_key> with your actual Chunkr.ai API Key. You obtained this in the \"Welcome\" step.\n2.  **File Content:** The `file` parameter is dynamically set to the base64 encoded PDF from \"Extract from File\".\n3.  **File Name:** The `file_name` parameter uses the `fileNameSnake` variable from \"Set File Name\".\n4.  This creates a new processing task on Chunkr.ai"
          },
          "typeVersion": 1
        },
        {
          "id": "45dd3735-1c1a-4b46-ad10-d79234f01b7a",
          "name": "Wait Before Polling the Chunkr Result",
          "type": "n8n-nodes-base.wait",
          "position": [
            -480,
            20
          ],
          "webhookId": "23fb1820-b060-4e25-87c3-3c49f7ffb916",
          "parameters": {
            "amount": 10
          },
          "typeVersion": 1.1
        },
        {
          "id": "572c6ae1-cf9a-43ff-9c09-3bc650875d70",
          "name": "Sticky Note4",
          "type": "n8n-nodes-base.stickyNote",
          "position": [
            680,
            -600
          ],
          "parameters": {
            "width": 480,
            "height": 380,
            "content": "### Node: Extract Sections headers as fallback (Code)\n\nThis node extracts all detected section headers that were identified by chunkr. Chunkr is not ideal at finding these but does a great job generally in OCR\n\n**What it does:**\n* It iterates through the `chunks` and `segments` returned by Chunkr.ai.\n* It specifically looks for segments with `segment_type` equal to `'SectionHeader'`.\n* All found section header texts are collected and duplicates are removed.\n* **Purpose:** This provides a list of potential headings as a fallback, especially if the AI Agent cannot find a clear Table of Contents in the document's beginning."
          },
          "typeVersion": 1
        },
        {
          "id": "56cbaf07-965c-4718-b282-dd1b471ffa90",
          "name": "Sticky Note5",
          "type": "n8n-nodes-base.stickyNote",
          "position": [
            120,
            -600
          ],
          "parameters": {
            "width": 500,
            "height": 380,
            "content": "### Node: Take beginning of Document to look for Table of contents (Code)\n\n### ðŸš¨ðŸš¨ðŸš¨ INSERT A CHUNKR.AI API KEY HERE\n\n\nThis node extracts initial document content for AI analysis.\n\n**What it does:**\n* It takes the full Chunkr.ai output and extracts the text content of the first 10 \"chunks\".\n* This concatenated text is then passed to the AI Agent.\n* **Purpose:** The AI Agent will use this initial text to identify if a formal Table of Contents is present within the document itself, which is often more accurate than programmatically extracted section headers."
          },
          "typeVersion": 1
        },
        {
          "id": "2b103146-6917-4745-adff-cb790dbdd7a6",
          "name": "Return each section individually",
          "type": "n8n-nodes-base.code",
          "position": [
            2040,
            -400
          ],
          "parameters": {
            "jsCode": "// --- Two-Pass Heading Mapping with Levels, Rich Content, Simplified Boundaries & Multi-Item Output ---\n\n// Get data from the two specified previous nodes\nconst goldenTocContainer = $(\"Table of Content Agent\").first().json.output;\nconst chunkrOutputContainer = $('GET Chunkr Task').first().json.output;\n\nconsole.log(\"Script Start: Levels, Rich Content, Simplified Boundaries & Multi-Item Output\");\n\nconst goldenTocArray = goldenTocContainer?.tableOfContents || [];\nconst chunkrChunks = chunkrOutputContainer?.chunks || [];\n\nif (!goldenTocArray.length) {\n    console.error(\"STOP: Golden ToC array is empty or not found.\");\n    return [{ json: { error: \"Golden ToC array is empty.\" }}];\n}\nif (!chunkrChunks.length) {\n    console.error(\"STOP: Chunkr chunks array is empty or not found.\");\n    return [{ json: { error: \"Chunkr chunks array is empty.\" }}];\n}\nconsole.log(`Inputs loaded: Golden ToC items: ${goldenTocArray.length}, Chunkr Chunks: ${chunkrChunks.length}`);\n\n// --- Helper Functions ---\nfunction normalizeText(text) {\n    if (typeof text !== 'string') return '';\n    return text.toLowerCase().replace(/\\s+/g, ' ').trim();\n}\n\nconst flatGoldenHeadings = [];\nlet uniqueIdCounter = 0;\n\nfunction flattenGoldenToC(nodes, defaultParentLevel = 0) {\n    for (const node of nodes) {\n        const currentItemLevel = node.level !== undefined ? node.level : defaultParentLevel + 1;\n        if (node.text) {\n            flatGoldenHeadings.push({\n                id: uniqueIdCounter++,\n                originalText: node.text.trim(),\n                normalizedText: normalizeText(node.text.trim()),\n                level: currentItemLevel,\n                isMapped: false,\n                matchDetails: { // Initialize with fields that will hold extracted content\n                    type: \"Unmatched\", chunkIndex: -1, segmentIndex: -1, chunkId: null, // chunkId kept for internal ref if needed\n                    matchedSegmentContent: \"\", sourceSegmentType: null,\n                    sectionText: \"\", sectionHTML: \"\", sectionMarkdown: \"\"\n                    // Boundary indices for output are removed here\n                }\n            });\n        }\n        if (node.children && node.children.length > 0) {\n            flattenGoldenToC(node.children, currentItemLevel);\n        }\n    }\n}\nflattenGoldenToC(goldenTocArray, 0);\nconsole.log(`Golden ToC flattened: ${flatGoldenHeadings.length} total headings with levels.`);\n\nconst usedChunkIndices = new Set();\nlet internalProcessedToc = [];\nlet identifiedPdfToCItem = null;\n\n// --- Step 1: Identify and Create Entry for the PDF's Own Table of Contents Chunk ---\nlet pdfTocChunkIndex = -1;\nlet maxTocItemsInAChunk = 0;\nconst minThreshold = 3;\nconst percentageThreshold = Math.floor(flatGoldenHeadings.length * 0.10);\nconst TOC_CHUNK_THRESHOLD_COUNT = Math.min(Math.max(minThreshold, percentageThreshold), 15);\n\nconsole.log(`Pre-computation: Identifying PDF's own ToC Chunk (threshold: > ${TOC_CHUNK_THRESHOLD_COUNT} distinct golden items)`);\nif (flatGoldenHeadings.length > 0) {\n    for (let chunkIdx = 0; chunkIdx < chunkrChunks.length; chunkIdx++) {\n        const chunk = chunkrChunks[chunkIdx];\n        if (!chunk.segments || chunk.segments.length === 0) continue;\n        let combinedChunkText = chunk.segments.reduce((acc, seg) => acc + (seg.content ? normalizeText(seg.content) + \" \" : \"\"), \"\").trim();\n        if (!combinedChunkText) continue;\n        const foundIds = new Set(flatGoldenHeadings.filter(gh => gh.normalizedText && combinedChunkText.includes(gh.normalizedText)).map(gh => gh.id));\n        const distinctItemsCount = foundIds.size;\n        if (distinctItemsCount > TOC_CHUNK_THRESHOLD_COUNT && distinctItemsCount > maxTocItemsInAChunk) {\n            maxTocItemsInAChunk = distinctItemsCount;\n            pdfTocChunkIndex = chunkIdx;\n        }\n    }\n}\n\nif (pdfTocChunkIndex !== -1) {\n    const tocChunk = chunkrChunks[pdfTocChunkIndex];\n    let tocContentSample = (tocChunk.segments && tocChunk.segments.length > 0)\n        ? tocChunk.segments.map(s => s.content || \"\").join(' ').substring(0, 150) + \"...\"\n        : \"[No segment content for sample]\";\n    identifiedPdfToCItem = {\n        id: \"pdf_toc_\" + pdfTocChunkIndex,\n        originalText: \"Document Table of Contents (Auto-Detected)\",\n        level: 1,\n        isMapped: true,\n        matchDetails: {\n            type: \"Auto-Detected PDF ToC\",\n            chunkIndex: pdfTocChunkIndex, segmentIndex: 0, chunkId: tocChunk.chunk_id,\n            matchedSegmentContent: `[Chunk ${pdfTocChunkIndex} (ID: ${tocChunk.chunk_id || 'N/A'}) auto-identified as PDF ToC, ~${maxTocItemsInAChunk} golden items. Sample: ${normalizeText(tocContentSample)}]`,\n            sourceSegmentType: \"AggregatedChunkAsPDFToC\",\n            sectionText: \"\", sectionHTML: \"\", sectionMarkdown: \"\"\n        }\n    };\n    usedChunkIndices.add(pdfTocChunkIndex);\n    console.log(`PDF ToC Chunk identified: Index ${pdfTocChunkIndex}.`);\n} else {\n    console.log(\"No single dominant PDF ToC Chunk identified.\");\n}\n\n// --- Pass 1: Anchor Golden Headings with 'SectionHeader' ---\nconsole.log(\"\\n--- Starting Pass 1 for Golden ToC: Matching 'SectionHeader' Segments ---\");\nflatGoldenHeadings.forEach(goldenHeading => {\n    if (!goldenHeading.normalizedText || goldenHeading.isMapped) return;\n    for (let chunkIdx = 0; chunkIdx < chunkrChunks.length; chunkIdx++) {\n        if (usedChunkIndices.has(chunkIdx)) continue;\n        const chunk = chunkrChunks[chunkIdx];\n        for (let segIdx = 0; segIdx < chunk.segments.length; segIdx++) {\n            const segment = chunk.segments[segIdx];\n            if (segment.segment_type === 'SectionHeader' && segment.content && normalizeText(segment.content) === goldenHeading.normalizedText) {\n                console.log(`  âœ… PASS 1: \"${goldenHeading.originalText}\" (L${goldenHeading.level}) -> SectionHeader in Chunk ${chunkIdx}`);\n                goldenHeading.isMapped = true;\n                goldenHeading.matchDetails = { // Overwrite initial matchDetails\n                    type: \"SectionHeader Exact\", chunkIndex: chunkIdx, segmentIndex: segIdx, chunkId: chunk.chunk_id,\n                    matchedSegmentContent: segment.content, sourceSegmentType: segment.segment_type,\n                    sectionText: \"\", sectionHTML: \"\", sectionMarkdown: \"\"\n                };\n                usedChunkIndices.add(chunkIdx);\n                break;\n            }\n        }\n        if (goldenHeading.isMapped) break;\n    }\n});\nconsole.log(`--- Pass 1 Complete: ${flatGoldenHeadings.filter(h => h.isMapped).length} golden headings mapped initially.`);\n\n// --- Pass 2: Find Remaining Golden Headings (Content Includes) ---\nconsole.log(\"\\n--- Starting Pass 2 for Golden ToC: Content Search (Simplified) ---\");\nlet searchAfterChunkIndex_Pass2 = identifiedPdfToCItem ? identifiedPdfToCItem.matchDetails.chunkIndex : -1;\n\nflatGoldenHeadings.forEach(goldenHeading => {\n    if (goldenHeading.isMapped) {\n        if (goldenHeading.matchDetails.chunkIndex > searchAfterChunkIndex_Pass2) {\n            searchAfterChunkIndex_Pass2 = goldenHeading.matchDetails.chunkIndex;\n        }\n        return;\n    }\n    if (!goldenHeading.normalizedText) return;\n    console.log(`Pass 2 - Seeking: \"${goldenHeading.originalText}\" (L${goldenHeading.level}) (after chunk ${searchAfterChunkIndex_Pass2})`);\n    let potentialMatches = [];\n    for (let chunkIdx = searchAfterChunkIndex_Pass2 + 1; chunkIdx < chunkrChunks.length; chunkIdx++) {\n        if (usedChunkIndices.has(chunkIdx)) continue;\n        const chunk = chunkrChunks[chunkIdx];\n        for (let segIdx = 0; segIdx < chunk.segments.length; segIdx++) {\n            const segment = chunk.segments[segIdx];\n            if (segment.content && normalizeText(segment.content).includes(goldenHeading.normalizedText)) {\n                potentialMatches.push({\n                    chunkIndex: chunkIdx, segmentIndex: segIdx, chunkId: chunk.chunk_id,\n                    matchedSegmentContent: segment.content, segmentType: segment.segment_type\n                });\n            }\n        }\n    }\n    if (!potentialMatches.length) {\n        console.log(`  âŒ PASS 2: NO RAW MATCHES for \"${goldenHeading.originalText}\" (L${goldenHeading.level}).`);\n        return;\n    }\n    potentialMatches.sort((a, b) => (a.chunkIndex !== b.chunkIndex ? a.chunkIndex - b.chunkIndex : a.segmentIndex - b.segmentIndex));\n    let chosenMatch = potentialMatches.find(match => !usedChunkIndices.has(match.chunkIndex));\n\n    if (chosenMatch) {\n        console.log(`  âœ… PASS 2: \"${goldenHeading.originalText}\" (L${goldenHeading.level}) -> Chunk ${chosenMatch.chunkIndex}, Seg ${chosenMatch.segmentIndex}`);\n        goldenHeading.isMapped = true;\n        goldenHeading.matchDetails = { // Overwrite initial matchDetails\n            type: \"Content Includes\", chunkIndex: chosenMatch.chunkIndex, segmentIndex: chosenMatch.segmentIndex, chunkId: chosenMatch.chunkId,\n            matchedSegmentContent: chosenMatch.matchedSegmentContent, sourceSegmentType: chosenMatch.segmentType,\n            sectionText: \"\", sectionHTML: \"\", sectionMarkdown: \"\"\n        };\n        usedChunkIndices.add(chosenMatch.chunkIndex);\n        searchAfterChunkIndex_Pass2 = chosenMatch.chunkIndex;\n    } else {\n        console.log(`  âŒ PASS 2: NO SUITABLE UNUSED CHUNK for \"${goldenHeading.originalText}\" (L${goldenHeading.level}).`);\n    }\n});\n\n// --- Consolidate, Sort, and Extract Section Content (Text, HTML, Markdown) ---\nif (identifiedPdfToCItem) {\n    internalProcessedToc.push(identifiedPdfToCItem);\n}\nflatGoldenHeadings.forEach(gh => internalProcessedToc.push(gh));\n\ninternalProcessedToc.sort((a, b) => {\n    const aChunk = a.matchDetails.chunkIndex;\n    const bChunk = b.matchDetails.chunkIndex;\n    const aSeg = a.matchDetails.segmentIndex;\n    const bSeg = b.matchDetails.segmentIndex;\n    if (aChunk !== bChunk) return aChunk - bChunk;\n    if (aSeg !== bSeg) return aSeg - bSeg;\n    return (a.id && b.id) ? String(a.id).localeCompare(String(b.id)) : 0;\n});\n\nconsole.log(\"\\n--- Extracting Section Content (Text, HTML, Markdown) for Mapped Items ---\");\n\nfunction getContentStartPoint(headingChunkIdx, headingSegIdx, allChunkrChunks) {\n    let contentStartChunkIdx = headingChunkIdx;\n    let contentStartSegmentIdx = headingSegIdx + 1;\n    if (headingChunkIdx >= allChunkrChunks.length || !allChunkrChunks[headingChunkIdx] || !allChunkrChunks[headingChunkIdx].segments) {\n        return { chunkIdx: headingChunkIdx, segmentIdx: headingSegIdx };\n    }\n    const headingChunk = allChunkrChunks[headingChunkIdx];\n    if (contentStartSegmentIdx >= headingChunk.segments.length) {\n        contentStartChunkIdx++;\n        contentStartSegmentIdx = 0;\n    }\n    return { chunkIdx: contentStartChunkIdx, segmentIdx: contentStartSegmentIdx };\n}\n\nfunction extractSectionContents(contentStartChunkIdx, contentStartSegmentIdx, nextSectionStartChunkIdx, nextSectionStartSegIdx, allChunkrChunks) {\n    let accumulatedText = \"\";\n    let accumulatedHtml = \"\";\n    let accumulatedMarkdown = \"\";\n    for (let cIdx = contentStartChunkIdx; cIdx < allChunkrChunks.length; cIdx++) {\n        const chunk = allChunkrChunks[cIdx];\n        if (!chunk || !chunk.segments) continue;\n        const sStart = (cIdx === contentStartChunkIdx) ? contentStartSegmentIdx : 0;\n        let sEnd = chunk.segments.length;\n        if (cIdx === nextSectionStartChunkIdx) sEnd = nextSectionStartSegIdx;\n        for (let sIdx = sStart; sIdx < sEnd; sIdx++) {\n            const segment = chunk.segments[sIdx];\n            if (segment) {\n                if (segment.content) accumulatedText += segment.content + \"\\n\";\n                accumulatedHtml += (segment.html || \"\") + \"\\n\";\n                accumulatedMarkdown += (segment.markdown || \"\") + \"\\n\";\n            }\n        }\n        if (cIdx >= nextSectionStartChunkIdx && nextSectionStartChunkIdx < allChunkrChunks.length) break;\n    }\n    return {\n        text: accumulatedText.trim(),\n        html: accumulatedHtml.trim(),\n        markdown: accumulatedMarkdown.trim()\n    };\n}\n\nfor (let i = 0; i < internalProcessedToc.length; i++) {\n    const currentItem = internalProcessedToc[i];\n    if (!currentItem.isMapped || !currentItem.matchDetails || currentItem.matchDetails.chunkIndex === -1) {\n        continue;\n    }\n\n    const headingChunkIdx = currentItem.matchDetails.chunkIndex;\n    const headingSegIdx = currentItem.matchDetails.segmentIndex;\n\n    // Determine end of current section (start of next *mapped* section)\n    let nextSectionStartChunkIdx = chunkrChunks.length;\n    let nextSectionStartSegIdx = 0;\n\n    for (let j = i + 1; j < internalProcessedToc.length; j++) {\n        if (internalProcessedToc[j].isMapped && internalProcessedToc[j].matchDetails && internalProcessedToc[j].matchDetails.chunkIndex !== -1) {\n            nextSectionStartChunkIdx = internalProcessedToc[j].matchDetails.chunkIndex;\n            nextSectionStartSegIdx = internalProcessedToc[j].matchDetails.segmentIndex;\n            break;\n        }\n    }\n    // These end boundaries are used for extraction, but not stored in matchDetails for output\n    \n    let contentExtractionStartChunk = headingChunkIdx;\n    let contentExtractionStartSegment = headingSegIdx;\n\n    if (currentItem.id && String(currentItem.id).startsWith(\"pdf_toc_\")) {\n        contentExtractionStartChunk = headingChunkIdx;\n        contentExtractionStartSegment = 0; \n    } else {\n        const contentStartPoint = getContentStartPoint(headingChunkIdx, headingSegIdx, chunkrChunks);\n        contentExtractionStartChunk = contentStartPoint.chunkIdx;\n        contentExtractionStartSegment = contentStartPoint.segmentIdx;\n    }\n    \n    const sectionContents = extractSectionContents(\n        contentExtractionStartChunk, contentExtractionStartSegment,\n        nextSectionStartChunkIdx, nextSectionStartSegIdx,\n        chunkrChunks\n    );\n\n    currentItem.matchDetails.sectionText = sectionContents.text;\n    currentItem.matchDetails.sectionHTML = sectionContents.html;\n    currentItem.matchDetails.sectionMarkdown = sectionContents.markdown;\n}\n\n// --- Final Output Formatting to Individual n8n Items (Simplified) ---\nconst outputN8nItems = [];\ninternalProcessedToc.forEach(item => {\n    if (item.isMapped && item.matchDetails && item.matchDetails.chunkIndex !== -1) {\n        const detail = item.matchDetails;\n        outputN8nItems.push({\n            json: {\n                heading: item.originalText,\n                headingLevel: item.level !== undefined ? item.level : 1,\n                sectionText: detail.sectionText || \"\",\n                sectionHTML: detail.sectionHTML || \"\",\n                sectionMarkdown: detail.sectionMarkdown || \"\"\n                // Removed: sourceChunkId, sectionStartChunkIndex, sectionStartSegmentIndex,\n                // sectionEndChunkIndex, sectionEndSegmentIndex\n            }\n        });\n    }\n});\n\nconsole.log(`--- Processing Complete. Returning ${outputN8nItems.length} mapped sections as individual items. ---`);\nif (outputN8nItems.length > 0) {\n    console.log(\"\\n--- Sample of First Output Item (JSON content) ---\");\n    console.log(JSON.stringify(outputN8nItems[0].json, null, 2));\n}\n\nif (outputN8nItems.length === 0 && (goldenTocArray.length > 0 || chunkrChunks.length > 0)) {\n    console.warn(\"No sections were successfully mapped to output.\");\n    return [{ json: { warning: \"No sections mapped.\" } }];\n}\n\nreturn outputN8nItems;"
          },
          "typeVersion": 2
        },
        {
          "id": "8622fab4-edcc-41d4-8456-0c652e8f6eb2",
          "name": "Table of Content Agent",
          "type": "@n8n/n8n-nodes-langchain.agent",
          "position": [
            1420,
            -160
          ],
          "parameters": {
            "text": "=You are an expert at understanding document structure. Based on the following ordered list of section headings from a document, please analyze the numbering (e.g., 1., 1.1, 1.1.1, A., B.) and semantic content to create a nested JSON object representing the document's hierarchy.\n\nEach node in the JSON must have a \"title\" (the heading text) and a \"children\" (an array of child nodes).\n\n**Example:**\nInput List: [\"1. Introduction\", \"1.1 Background\", \"1.2 Scope\", \"2. Methodology\", \"2.1 Data Collection\"]\nDesired JSON Output:\n[\n  {\n    \"title\": \"1. Introduction\",\n    \"children\": [\n      { \"title\": \"1.1 Background\", \"children\": [] },\n      { \"title\": \"1.2 Scope\", \"children\": [] }\n    ]\n  },\n  {\n    \"title\": \"2. Methodology\",\n    \"children\": [\n      { \"title\": \"2.1 Data Collection\", \"children\": [] }\n    ]\n  }\n]\n\n**These Headings were extracted programatically:**\n(these are generated using OCR and should only be used as fallback. this might include too many headings, or may be missing some. only use if no TOC is found in the beginning of the document)\n{{ $('Extract Sections headers as fallback').first().json.headings }}\n\n\n**This is the first pages of the document**\n{{ $('Take beginning of Document to look for Table of contents').first().json.firstXNumberOfChunks }}\n(may or may not contain a table of contents. if it does, use as primary source of truth)\n\nyour task is to use the above sources to construct a table of contents.\noutput in json using the required format.",
            "options": {},
            "promptType": "define",
            "hasOutputParser": true
          },
          "typeVersion": 2
        },
        {
          "id": "b627fe7d-f342-40f6-912f-c090a619c96c",
          "name": "Return the whole document",
          "type": "n8n-nodes-base.code",
          "position": [
            2120,
            340
          ],
          "parameters": {
            "jsCode": "const goldenTocContainer = $(\"Table of Content Agent\").first().json.output;\nconst chunkrOutputContainer = $('GET Chunkr Task').first().json.output;\n\n\nconsole.log(\"Script Start: Adding Heading Levels\");\n\nconst goldenTocArray = goldenTocContainer?.tableOfContents || [];\nconst chunkrChunks = chunkrOutputContainer?.chunks || [];\n\nif (!goldenTocArray.length) {\n    console.error(\"STOP: Golden ToC array is empty or not found.\");\n    return [{ json: { error: \"Golden ToC array is empty.\", processedSections: [] }}];\n}\nif (!chunkrChunks.length) {\n    console.error(\"STOP: Chunkr chunks array is empty or not found.\");\n    return [{ json: { error: \"Chunkr chunks array is empty.\", processedSections: [] }}];\n}\nconsole.log(`Inputs loaded: Golden ToC items: ${goldenTocArray.length}, Chunkr Chunks: ${chunkrChunks.length}`);\n\n// --- Helper Functions ---\nfunction normalizeText(text) {\n    if (typeof text !== 'string') return '';\n    return text.toLowerCase().replace(/\\s+/g, ' ').trim();\n}\n\nconst flatGoldenHeadings = [];\nlet uniqueIdCounter = 0;\n\n// Modified flattenGoldenToC to capture the 'level' property\n// Assumes 'node.level' from your input goldenTocArray is the authoritative source.\n// Adds a defaultLevel for robustness if 'node.level' is unexpectedly missing.\nfunction flattenGoldenToC(nodes, defaultParentLevel = 0) {\n    for (const node of nodes) {\n        // Determine the current item's level: use explicit if present, else infer from parent.\n        const currentItemLevel = node.level !== undefined ? node.level : defaultParentLevel + 1;\n\n        if (node.text) {\n            flatGoldenHeadings.push({\n                id: uniqueIdCounter++,\n                originalText: node.text.trim(),\n                normalizedText: normalizeText(node.text.trim()),\n                level: currentItemLevel, // Store the heading level\n                isMapped: false,\n                matchDetails: { // Initialize all expected matchDetail fields\n                    type: \"Unmatched\", chunkIndex: -1, segmentIndex: -1, chunkId: null,\n                    matchedSegmentContent: \"\", sourceSegmentType: null,\n                    sectionText: \"\", sectionHTML: \"\", sectionMarkdown: \"\",\n                    sectionStartChunkIndex: -1, sectionStartSegmentIndex: -1,\n                    sectionEndChunkIndex: -1, sectionEndSegmentIndex: -1\n                }\n            });\n        }\n        if (node.children && node.children.length > 0) {\n            // Children's level is determined by their own 'level' or inferred from current item's level\n            flattenGoldenToC(node.children, currentItemLevel);\n        }\n    }\n}\nflattenGoldenToC(goldenTocArray, 0); // Initial call, top-level items will use their own 'level' or default to 1\nconsole.log(`Golden ToC flattened: ${flatGoldenHeadings.length} total headings with levels.`);\n\nconst usedChunkIndices = new Set();\nlet internalProcessedToc = [];\nlet identifiedPdfToCItem = null;\n\n// --- Step 1: Identify and Create Entry for the PDF's Own Table of Contents Chunk ---\nlet pdfTocChunkIndex = -1;\nlet maxTocItemsInAChunk = 0;\nconst minThreshold = 3;\nconst percentageThreshold = Math.floor(flatGoldenHeadings.length * 0.10);\nconst TOC_CHUNK_THRESHOLD_COUNT = Math.min(Math.max(minThreshold, percentageThreshold), 15);\n\nconsole.log(`Pre-computation: Identifying PDF's own ToC Chunk (threshold: > ${TOC_CHUNK_THRESHOLD_COUNT} distinct golden items)`);\nif (flatGoldenHeadings.length > 0) {\n    for (let chunkIdx = 0; chunkIdx < chunkrChunks.length; chunkIdx++) {\n        const chunk = chunkrChunks[chunkIdx];\n        if (!chunk.segments || chunk.segments.length === 0) continue;\n        let combinedChunkText = chunk.segments.reduce((acc, seg) => acc + (seg.content ? normalizeText(seg.content) + \" \" : \"\"), \"\").trim();\n        if (!combinedChunkText) continue;\n        const foundIds = new Set(flatGoldenHeadings.filter(gh => gh.normalizedText && combinedChunkText.includes(gh.normalizedText)).map(gh => gh.id));\n        const distinctItemsCount = foundIds.size;\n        if (distinctItemsCount > TOC_CHUNK_THRESHOLD_COUNT && distinctItemsCount > maxTocItemsInAChunk) {\n            maxTocItemsInAChunk = distinctItemsCount;\n            pdfTocChunkIndex = chunkIdx;\n        }\n    }\n}\n\nif (pdfTocChunkIndex !== -1) {\n    const tocChunk = chunkrChunks[pdfTocChunkIndex];\n    let tocContentSample = (tocChunk.segments && tocChunk.segments.length > 0)\n        ? tocChunk.segments.map(s => s.content || \"\").join(' ').substring(0, 150) + \"...\"\n        : \"[No segment content for sample]\";\n    identifiedPdfToCItem = {\n        id: \"pdf_toc_\" + pdfTocChunkIndex,\n        originalText: \"Document Table of Contents (Auto-Detected)\",\n        level: 1, // Assign level 1 to the auto-detected ToC\n        isMapped: true,\n        matchDetails: {\n            type: \"Auto-Detected PDF ToC\",\n            chunkIndex: pdfTocChunkIndex, segmentIndex: 0, chunkId: tocChunk.chunk_id,\n            matchedSegmentContent: `[Chunk ${pdfTocChunkIndex} (ID: ${tocChunk.chunk_id || 'N/A'}) auto-identified as PDF ToC, ~${maxTocItemsInAChunk} golden items. Sample: ${normalizeText(tocContentSample)}]`,\n            sourceSegmentType: \"AggregatedChunkAsPDFToC\",\n            sectionText: \"\", sectionHTML: \"\", sectionMarkdown: \"\",\n            sectionStartChunkIndex: pdfTocChunkIndex, sectionStartSegmentIndex: 0,\n            sectionEndChunkIndex: -1, sectionEndSegmentIndex: -1\n        }\n    };\n    usedChunkIndices.add(pdfTocChunkIndex);\n    console.log(`PDF ToC Chunk identified: Index ${pdfTocChunkIndex}. Level set to 1.`);\n} else {\n    console.log(\"No single dominant PDF ToC Chunk identified.\");\n}\n\n// --- Pass 1: Anchor Golden Headings with 'SectionHeader' ---\nconsole.log(\"\\n--- Starting Pass 1 for Golden ToC: Matching 'SectionHeader' Segments ---\");\nflatGoldenHeadings.forEach(goldenHeading => {\n    if (!goldenHeading.normalizedText || goldenHeading.isMapped) return;\n    for (let chunkIdx = 0; chunkIdx < chunkrChunks.length; chunkIdx++) {\n        if (usedChunkIndices.has(chunkIdx)) continue;\n        const chunk = chunkrChunks[chunkIdx];\n        for (let segIdx = 0; segIdx < chunk.segments.length; segIdx++) {\n            const segment = chunk.segments[segIdx];\n            if (segment.segment_type === 'SectionHeader' && segment.content && normalizeText(segment.content) === goldenHeading.normalizedText) {\n                console.log(`  âœ… PASS 1: \"${goldenHeading.originalText}\" (L${goldenHeading.level}) -> SectionHeader in Chunk ${chunkIdx}`);\n                goldenHeading.isMapped = true;\n                goldenHeading.matchDetails = {\n                    type: \"SectionHeader Exact\", chunkIndex: chunkIdx, segmentIndex: segIdx, chunkId: chunk.chunk_id,\n                    matchedSegmentContent: segment.content, sourceSegmentType: segment.segment_type,\n                    sectionText: \"\", sectionHTML: \"\", sectionMarkdown: \"\",\n                    sectionStartChunkIndex: chunkIdx, sectionStartSegmentIndex: segIdx,\n                    sectionEndChunkIndex: -1, sectionEndSegmentIndex: -1\n                };\n                usedChunkIndices.add(chunkIdx);\n                break;\n            }\n        }\n        if (goldenHeading.isMapped) break;\n    }\n});\nconsole.log(`--- Pass 1 Complete: ${flatGoldenHeadings.filter(h => h.isMapped).length} golden headings mapped initially.`);\n\n// --- Pass 2: Find Remaining Golden Headings (Content Includes) ---\nconsole.log(\"\\n--- Starting Pass 2 for Golden ToC: Content Search (Simplified) ---\");\nlet searchAfterChunkIndex_Pass2 = identifiedPdfToCItem ? identifiedPdfToCItem.matchDetails.chunkIndex : -1;\n\nflatGoldenHeadings.forEach(goldenHeading => {\n    if (goldenHeading.isMapped) {\n        if (goldenHeading.matchDetails.chunkIndex > searchAfterChunkIndex_Pass2) {\n            searchAfterChunkIndex_Pass2 = goldenHeading.matchDetails.chunkIndex;\n        }\n        return;\n    }\n    if (!goldenHeading.normalizedText) return;\n\n    console.log(`Pass 2 - Seeking: \"${goldenHeading.originalText}\" (L${goldenHeading.level}) (after chunk ${searchAfterChunkIndex_Pass2})`);\n    let potentialMatches = [];\n    for (let chunkIdx = searchAfterChunkIndex_Pass2 + 1; chunkIdx < chunkrChunks.length; chunkIdx++) {\n        if (usedChunkIndices.has(chunkIdx)) continue;\n        const chunk = chunkrChunks[chunkIdx];\n        for (let segIdx = 0; segIdx < chunk.segments.length; segIdx++) {\n            const segment = chunk.segments[segIdx];\n            if (segment.content && normalizeText(segment.content).includes(goldenHeading.normalizedText)) {\n                potentialMatches.push({\n                    chunkIndex: chunkIdx, segmentIndex: segIdx, chunkId: chunk.chunk_id,\n                    matchedSegmentContent: segment.content, segmentType: segment.segment_type\n                });\n            }\n        }\n    }\n    if (!potentialMatches.length) {\n        console.log(`  âŒ PASS 2: NO RAW MATCHES for \"${goldenHeading.originalText}\" (L${goldenHeading.level}).`);\n        return;\n    }\n    potentialMatches.sort((a, b) => (a.chunkIndex !== b.chunkIndex ? a.chunkIndex - b.chunkIndex : a.segmentIndex - b.segmentIndex));\n    let chosenMatch = potentialMatches.find(match => !usedChunkIndices.has(match.chunkIndex));\n\n    if (chosenMatch) {\n        console.log(`  âœ… PASS 2: \"${goldenHeading.originalText}\" (L${goldenHeading.level}) -> Chunk ${chosenMatch.chunkIndex}, Seg ${chosenMatch.segmentIndex}`);\n        goldenHeading.isMapped = true;\n        goldenHeading.matchDetails = {\n            type: \"Content Includes\", chunkIndex: chosenMatch.chunkIndex, segmentIndex: chosenMatch.segmentIndex, chunkId: chosenMatch.chunkId,\n            matchedSegmentContent: chosenMatch.matchedSegmentContent, sourceSegmentType: chosenMatch.segmentType,\n            sectionText: \"\", sectionHTML: \"\", sectionMarkdown: \"\",\n            sectionStartChunkIndex: chosenMatch.chunkIndex, sectionStartSegmentIndex: chosenMatch.segmentIndex,\n            sectionEndChunkIndex: -1, sectionEndSegmentIndex: -1\n        };\n        usedChunkIndices.add(chosenMatch.chunkIndex);\n        searchAfterChunkIndex_Pass2 = chosenMatch.chunkIndex;\n    } else {\n        console.log(`  âŒ PASS 2: NO SUITABLE UNUSED CHUNK for \"${goldenHeading.originalText}\" (L${goldenHeading.level}).`);\n    }\n});\n\n// --- Consolidate, Sort, and Extract Section Content (Text, HTML, Markdown) ---\nif (identifiedPdfToCItem) {\n    internalProcessedToc.push(identifiedPdfToCItem);\n}\nflatGoldenHeadings.forEach(gh => internalProcessedToc.push(gh));\n\ninternalProcessedToc.sort((a, b) => {\n    const aChunk = a.matchDetails.chunkIndex;\n    const bChunk = b.matchDetails.chunkIndex;\n    const aSeg = a.matchDetails.segmentIndex;\n    const bSeg = b.matchDetails.segmentIndex;\n    if (aChunk !== bChunk) return aChunk - bChunk;\n    if (aSeg !== bSeg) return aSeg - bSeg;\n    return (a.id && b.id) ? String(a.id).localeCompare(String(b.id)) : 0;\n});\n\nconsole.log(\"\\n--- Extracting Section Content (Text, HTML, Markdown) for Mapped Items ---\");\n\nfunction getContentStartPoint(headingChunkIdx, headingSegIdx, allChunkrChunks) {\n    let contentStartChunkIdx = headingChunkIdx;\n    let contentStartSegmentIdx = headingSegIdx + 1;\n    if (headingChunkIdx >= allChunkrChunks.length || !allChunkrChunks[headingChunkIdx] || !allChunkrChunks[headingChunkIdx].segments) {\n        return { chunkIdx: headingChunkIdx, segmentIdx: headingSegIdx };\n    }\n    const headingChunk = allChunkrChunks[headingChunkIdx];\n    if (contentStartSegmentIdx >= headingChunk.segments.length) {\n        contentStartChunkIdx++;\n        contentStartSegmentIdx = 0;\n    }\n    return { chunkIdx: contentStartChunkIdx, segmentIdx: contentStartSegmentIdx };\n}\n\nfunction extractSectionContents(contentStartChunkIdx, contentStartSegmentIdx, nextSectionStartChunkIdx, nextSectionStartSegIdx, allChunkrChunks) {\n    let accumulatedText = \"\";\n    let accumulatedHtml = \"\";\n    let accumulatedMarkdown = \"\";\n    for (let cIdx = contentStartChunkIdx; cIdx < allChunkrChunks.length; cIdx++) {\n        const chunk = allChunkrChunks[cIdx];\n        if (!chunk || !chunk.segments) continue;\n        const sStart = (cIdx === contentStartChunkIdx) ? contentStartSegmentIdx : 0;\n        let sEnd = chunk.segments.length;\n        if (cIdx === nextSectionStartChunkIdx) sEnd = nextSectionStartSegIdx;\n        for (let sIdx = sStart; sIdx < sEnd; sIdx++) {\n            const segment = chunk.segments[sIdx];\n            if (segment) {\n                if (segment.content) accumulatedText += segment.content + \"\\n\";\n                accumulatedHtml += (segment.html || \"\") + \"\\n\";\n                accumulatedMarkdown += (segment.markdown || \"\") + \"\\n\";\n            }\n        }\n        if (cIdx >= nextSectionStartChunkIdx && nextSectionStartChunkIdx < allChunkrChunks.length) break;\n    }\n    return {\n        text: accumulatedText.trim(),\n        html: accumulatedHtml.trim(),\n        markdown: accumulatedMarkdown.trim()\n    };\n}\n\nfor (let i = 0; i < internalProcessedToc.length; i++) {\n    const currentItem = internalProcessedToc[i];\n    if (!currentItem.isMapped || !currentItem.matchDetails || currentItem.matchDetails.chunkIndex === -1) continue;\n\n    const headingChunkIdx = currentItem.matchDetails.chunkIndex;\n    const headingSegIdx = currentItem.matchDetails.segmentIndex;\n\n    let nextSectionStartChunkIdx = chunkrChunks.length;\n    let nextSectionStartSegIdx = 0;\n\n    for (let j = i + 1; j < internalProcessedToc.length; j++) {\n        if (internalProcessedToc[j].isMapped && internalProcessedToc[j].matchDetails && internalProcessedToc[j].matchDetails.chunkIndex !== -1) {\n            nextSectionStartChunkIdx = internalProcessedToc[j].matchDetails.chunkIndex;\n            nextSectionStartSegIdx = internalProcessedToc[j].matchDetails.segmentIndex;\n            break;\n        }\n    }\n    currentItem.matchDetails.sectionEndChunkIndex = nextSectionStartChunkIdx;\n    currentItem.matchDetails.sectionEndSegmentIndex = nextSectionStartSegIdx;\n    \n    let contentExtractionStartChunk = headingChunkIdx;\n    let contentExtractionStartSegment = headingSegIdx;\n\n    if (currentItem.id && String(currentItem.id).startsWith(\"pdf_toc_\")) {\n        contentExtractionStartChunk = headingChunkIdx; // Start of its own chunk\n        contentExtractionStartSegment = 0;             // From the very first segment\n    } else {\n        // For regular headings, content starts *after* the heading's segment\n        const contentStartPoint = getContentStartPoint(headingChunkIdx, headingSegIdx, chunkrChunks);\n        contentExtractionStartChunk = contentStartPoint.chunkIdx;\n        contentExtractionStartSegment = contentStartPoint.segmentIdx;\n    }\n    \n    const sectionContents = extractSectionContents(\n        contentExtractionStartChunk, contentExtractionStartSegment,\n        nextSectionStartChunkIdx, nextSectionStartSegIdx,\n        chunkrChunks\n    );\n\n    currentItem.matchDetails.sectionText = sectionContents.text;\n    currentItem.matchDetails.sectionHTML = sectionContents.html;\n    currentItem.matchDetails.sectionMarkdown = sectionContents.markdown;\n}\n\n// --- Final Output Formatting to a Single n8n Item with an Array of Sections ---\nconst outputSectionsArray = [];\ninternalProcessedToc.forEach(item => {\n    if (item.isMapped && item.matchDetails && item.matchDetails.chunkIndex !== -1) {\n        const detail = item.matchDetails;\n        outputSectionsArray.push({\n            heading: item.originalText,\n            headingLevel: item.level !== undefined ? item.level : 1, // Add headingLevel, default to 1 if missing\n            sectionText: detail.sectionText || \"\",\n            sectionHTML: detail.sectionHTML || \"\",\n            sectionMarkdown: detail.sectionMarkdown || \"\",\n            sourceChunkId: detail.chunkId || null,\n            sectionStartChunkIndex: detail.sectionStartChunkIndex,\n            sectionStartSegmentIndex: detail.sectionStartSegmentIndex,\n            sectionEndChunkIndex: detail.sectionEndChunkIndex,\n            sectionEndSegmentIndex: detail.sectionEndSegmentIndex,\n        });\n    }\n});\n\nconsole.log(`--- Processing Complete. Returning 1 item with ${outputSectionsArray.length} mapped sections. ---`);\nif (outputSectionsArray.length > 0) {\n    console.log(\"\\n--- Sample of First Section in Output Array (showing heading and level) ---\");\n    const sample = outputSectionsArray[0];\n    console.log(`Heading: \"${sample.heading}\", Level: ${sample.headingLevel}, TextLen: ${sample.sectionText.length}, HTMLLen: ${sample.sectionHTML.length}, MDLen: ${sample.sectionMarkdown.length}`);\n}\n\nif (outputSectionsArray.length === 0 && (goldenTocArray.length > 0 || chunkrChunks.length > 0)) {\n    console.warn(\"No sections were successfully mapped to output array.\");\n    return [{ json: { warning: \"No sections mapped.\", processedSections: [] } }];\n}\n\nreturn [{ json: { processedSections: outputSectionsArray } }];"
          },
          "typeVersion": 2
        },
        {
          "id": "14257369-a732-45cc-a45d-16408f9408d7",
          "name": "Create HTML document",
          "type": "n8n-nodes-base.code",
          "position": [
            2580,
            140
          ],
          "parameters": {
            "jsCode": "// n8n Code Node: Generate Full HTML Document\n\n// Assuming the input from the previous node is items[0]\nconst inputData = $('Return the whole document').first().json;\nconst processedSections = inputData.processedSections;\n\nif (!processedSections || !Array.isArray(processedSections)) {\n  console.error(\"Error: processedSections array not found in input or is not an array.\");\n  // Return an error or an empty HTML string to prevent workflow failure\n  return [{ json: { error: \"Input data is not in the expected format.\", html_output: \"\", fileName: \"error.html\" } }];\n}\n\nlet fullHtmlContent = \"\";\n\n// Start HTML Document\nfullHtmlContent += \"<!DOCTYPE html>\\n\";\nfullHtmlContent += '<html lang=\"en\">\\n';\nfullHtmlContent += \"<head>\\n\";\nfullHtmlContent += '  <meta charset=\"UTF-8\">\\n';\nfullHtmlContent += '  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\\n';\n\n// Attempt to use the first H1 heading as the page title\nlet pageTitle = \"Generated Document\";\nif (processedSections.length > 0 && processedSections[0].heading) {\n    // A simple way to find a prominent heading for the title\n    const firstRealHeading = processedSections.find(s => s.headingLevel > 0 && s.heading !== \"Document Table of Contents (Auto-Detected)\");\n    pageTitle = firstRealHeading ? firstRealHeading.heading : (processedSections[0].heading || pageTitle);\n}\nfullHtmlContent += `  <title>${pageTitle.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\")}</title>\\n`;\n\n// Optional: Add some basic styling\nfullHtmlContent += `  <style>\n    body { font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; padding: 20px; max-width: 900px; margin: 0 auto; color: #333; }\n    h1, h2, h3, h4, h5, h6 { margin-top: 1.8em; margin-bottom: 0.6em; line-height: 1.2; color: #111; }\n    h1 { font-size: 2.2em; }\n    h2 { font-size: 1.8em; }\n    h3 { font-size: 1.5em; }\n    p { margin-bottom: 1em; }\n    pre, code { font-family: monospace; background-color: #f4f4f4; padding: 2px 4px; border-radius: 3px;}\n    pre { padding: 10px; overflow-x: auto; }\n    table { border-collapse: collapse; width: 100%; margin-bottom: 1em; }\n    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }\n    th { background-color: #f2f2f2; }\n    img { max-width: 100%; height: auto; display: block; margin: 1em 0; }\n  </style>\\n`;\n\nfullHtmlContent += \"</head>\\n\";\nfullHtmlContent += \"<body>\\n\\n\";\n\nprocessedSections.forEach(section => {\n  // Ensure heading and headingLevel are present and valid\n  if (section.heading && typeof section.headingLevel === 'number' && section.headingLevel > 0 && section.headingLevel <= 6) {\n    // Basic sanitization for heading text to prevent HTML injection if source is untrusted\n    const safeHeading = section.heading.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n    fullHtmlContent += `<h${section.headingLevel}>${safeHeading}</h${section.headingLevel}>\\n`;\n  }\n\n  // Append the section's HTML content\n  // It's assumed section.sectionHTML is already valid HTML for the body of the section\n  fullHtmlContent += (section.sectionHTML || \"\") + \"\\n\\n\";\n});\n\nfullHtmlContent += \"</body>\\n\";\nfullHtmlContent += \"</html>\";\n\n// Output the generated HTML string. This can then be used by a \"Write Binary File\" node\n// or other nodes that can handle file content.\nreturn [{ json: { fullHtmlContent} }];"
          },
          "typeVersion": 2
        },
        {
          "id": "3c472dcc-492b-4eb1-8c4d-bef5565047ba",
          "name": "HTML",
          "type": "n8n-nodes-base.html",
          "position": [
            2780,
            140
          ],
          "parameters": {
            "html": "{{ $json.fullHtmlContent }}"
          },
          "typeVersion": 1.2
        },
        {
          "id": "b912a32d-ae45-40f7-a5a4-e180cf306c6e",
          "name": "Move Binary Data",
          "type": "n8n-nodes-base.moveBinaryData",
          "position": [
            3000,
            140
          ],
          "parameters": {
            "mode": "jsonToBinary",
            "options": {
              "fileName": "={{ $('Set File Name').item.json.fileNameSnake }}.html",
              "mimeType": "text/html",
              "useRawData": true
            },
            "sourceKey": "html",
            "convertAllData": false
          },
          "typeVersion": 1
        },
        {
          "id": "10b96111-14e2-4061-82ae-643fb243894d",
          "name": "Create Markdown Document",
          "type": "n8n-nodes-base.code",
          "position": [
            2600,
            500
          ],
          "parameters": {
            "jsCode": "// n8n Code Node: Generate Full Markdown Document\n\n// Assuming the input from the previous node is items[0]\nconst inputData = $('Return the whole document').first().json;\nconst processedSections = inputData.processedSections;\n\nif (!processedSections || !Array.isArray(processedSections)) {\n  console.error(\"Error: processedSections array not found in input or is not an array.\");\n  return [{ json: { error: \"Input data is not in the expected format.\", markdown_output: \"\", fileName: \"error.md\" } }];\n}\n\nlet fullMarkdownContent = \"\";\n\nprocessedSections.forEach(section => {\n  // Ensure heading and headingLevel are present and valid\n  if (section.heading && typeof section.headingLevel === 'number' && section.headingLevel > 0) {\n    // Repeat '#' for the heading level\n    const markdownHeaderPrefix = '#'.repeat(section.headingLevel);\n    fullMarkdownContent += `${markdownHeaderPrefix} ${section.heading}\\n\\n`;\n  }\n\n  // Append the section's Markdown content\n  // It's assumed section.sectionMarkdown is already valid Markdown for the body of the section\n  fullMarkdownContent += (section.sectionMarkdown || \"\") + \"\\n\\n\"; // Add extra newline for spacing between sections\n});\n\n// Trim any excessive newlines at the very end\nfullMarkdownContent = fullMarkdownContent.trim();\n\n// Output the generated Markdown string.\nreturn [{ json: { fullMarkdownContent} }];"
          },
          "typeVersion": 2
        },
        {
          "id": "8eeb8129-e5e5-434f-b33a-35c7ea465a6d",
          "name": "Convert to File",
          "type": "n8n-nodes-base.convertToFile",
          "position": [
            2780,
            500
          ],
          "parameters": {
            "options": {
              "fileName": "={{ $('Set File Name').first().json.fileNameSnake }}.md"
            },
            "operation": "toText",
            "sourceProperty": "fullMarkdownContent"
          },
          "typeVersion": 1.1
        },
        {
          "id": "f50391c5-8ebc-48a6-a9d1-4c0d835ff5ea",
          "name": "Sticky Note6",
          "type": "n8n-nodes-base.stickyNote",
          "position": [
            1260,
            -600
          ],
          "parameters": {
            "width": 560,
            "height": 400,
            "content": "### Node: AI Agent (AI Agent)\n\nThis is where the Table of Contents is intelligently constructed.\n\n**What it does:**\n* It combines information from two sources:\n    * The raw section headers (from \"Extract Sections headers as fallback\").\n    * The beginning of the document (from \"Take beginning of Document to look for Table of contents\").\n* **Goal:** The AI's task is to create a nested JSON object representing the document's hierarchy, forming the Table of Contents."
          },
          "typeVersion": 1
        },
        {
          "id": "c03c377b-6204-40e6-8079-56c726e8f8a8",
          "name": "Sticky Note7",
          "type": "n8n-nodes-base.stickyNote",
          "position": [
            1940,
            -640
          ],
          "parameters": {
            "width": 400,
            "height": 400,
            "content": "## Return each section individually\n\nYou can return each heading + section individually, if you want need to process each chapter one by one. The current configuration outputs three versions for the section depending on your needs: Markdown, HTML, or just the text. "
          },
          "typeVersion": 1
        },
        {
          "id": "2b6e50ac-702a-4ff9-86cf-7fbde7a58dba",
          "name": "Sticky Note8",
          "type": "n8n-nodes-base.stickyNote",
          "position": [
            1980,
            60
          ],
          "parameters": {
            "width": 400,
            "height": 400,
            "content": "## ... OR Return the Document as a whole\n\nIf you want to process the document as a whole you can choose this path. You can download the markdown or html versions of the input PDF. \n\nif you use trigger by another workflow, you can just return the plain html or markdown without creating a file. this way you can use this workflow as a tool that an agent could use to parse PDFs"
          },
          "typeVersion": 1
        },
        {
          "id": "c4ec2654-ed9d-4bc3-a1a4-3e8f44aa115d",
          "name": "Sticky Note9",
          "type": "n8n-nodes-base.stickyNote",
          "position": [
            -2600,
            -820
          ],
          "parameters": {
            "width": 1540,
            "height": 260,
            "content": "# Convert PDFs to structured JSON with the correct subheading hierarchy\n\n## This workflow outputs finds the actual headings of each section, the corresponding text, and outputs each section as an individual item (or the whole document as one large JSON, depending on how you execute this workflow"
          },
          "typeVersion": 1
        },
        {
          "id": "a887cdad-a2c3-4477-a6ed-72d007f560a2",
          "name": "GET Chunkr Task",
          "type": "n8n-nodes-base.httpRequest",
          "position": [
            -260,
            -60
          ],
          "parameters": {
            "url": "=https://api.chunkr.ai/api/v1/task/{{ $('POST Chunkr Task').item.json.task_id }}",
            "options": {},
            "sendHeaders": true,
            "headerParameters": {
              "parameters": [
                {
                  "name": "Authorization",
                  "value": "<YOUR_CHUNKR_API_KEY>"
                }
              ]
            }
          },
          "typeVersion": 4.2
        },
        {
          "id": "cd52c24f-1698-4887-8d5d-248eb0a904fd",
          "name": "POST Chunkr Task",
          "type": "n8n-nodes-base.httpRequest",
          "position": [
            -700,
            20
          ],
          "parameters": {
            "url": "https://api.chunkr.ai/api/v1/task/parse",
            "method": "POST",
            "options": {},
            "jsonBody": "={\n  \"chunk_processing\": null,\n  \"error_handling\": null,\n  \"expires_in\": 123,\n  \"file\": \"{{ $('Convert the PDF to base64').item.json.data}}\",\n  \"file_name\": \"{{ $json.fileNameSnake }}\",\n  \"high_resolution\": false,\n  \"llm_processing\": null,\n  \"ocr_strategy\": null,\n  \"pipeline\": null,\n  \"segment_processing\": null,\n  \"segmentation_strategy\": null\n}",
            "sendBody": true,
            "sendHeaders": true,
            "specifyBody": "json",
            "headerParameters": {
              "parameters": [
                {
                  "name": "Authorization",
                  "value": "=<YOUR_CHUNKR_API_KEY>"
                }
              ]
            }
          },
          "typeVersion": 4.2
        },
        {
          "id": "5350ae70-85e1-44d2-bdb1-47b7a02708e5",
          "name": "Merge",
          "type": "n8n-nodes-base.merge",
          "position": [
            -1380,
            20
          ],
          "parameters": {},
          "typeVersion": 3.2
        }
      ],
      "pinData": {
        "When Executed by Another Workflow": [
          {
            "URL": "https://register.awmf.org/assets/guidelines/001-036l_S1_Management-des-erwartet-schwierigen-Atemwegs-beim-Kind_2021-05.pdf"
          }
        ],
        "When clicking â€˜Execute workflowâ€™": [
          {}
        ]
      },
      "connections": {
        "HTML": {
          "main": [
            [
              {
                "node": "Move Binary Data",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Merge": {
          "main": [
            [
              {
                "node": "Convert the PDF to base64",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Status is:": {
          "main": [
            [
              {
                "node": "Take beginning of Document to look for Table of contents",
                "type": "main",
                "index": 0
              }
            ],
            [
              {
                "node": "Wait Before Polling the Chunkr Result",
                "type": "main",
                "index": 0
              }
            ],
            [
              {
                "node": "Stop and Error",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Set File Name": {
          "main": [
            [
              {
                "node": "POST Chunkr Task",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "GET Chunkr Task": {
          "main": [
            [
              {
                "node": "Status is:",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "POST Chunkr Task": {
          "main": [
            [
              {
                "node": "Wait Before Polling the Chunkr Result",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Create HTML document": {
          "main": [
            [
              {
                "node": "HTML",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Download PDF from URL": {
          "main": [
            [
              {
                "node": "Merge",
                "type": "main",
                "index": 1
              }
            ]
          ]
        },
        "Table of Content Agent": {
          "main": [
            [
              {
                "node": "Return each section individually",
                "type": "main",
                "index": 0
              },
              {
                "node": "Return the whole document",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Create Markdown Document": {
          "main": [
            [
              {
                "node": "Convert to File",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Google Gemini Chat Model": {
          "ai_languageModel": [
            [
              {
                "node": "Table of Content Agent",
                "type": "ai_languageModel",
                "index": 0
              }
            ]
          ]
        },
        "Structured Output Parser": {
          "ai_outputParser": [
            [
              {
                "node": "Auto-fixing Output Parser",
                "type": "ai_outputParser",
                "index": 0
              }
            ]
          ]
        },
        "Auto-fixing Output Parser": {
          "ai_outputParser": [
            [
              {
                "node": "Table of Content Agent",
                "type": "ai_outputParser",
                "index": 0
              }
            ]
          ]
        },
        "Convert the PDF to base64": {
          "main": [
            [
              {
                "node": "Set File Name",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Google Gemini Chat Model1": {
          "ai_languageModel": [
            [
              {
                "node": "Auto-fixing Output Parser",
                "type": "ai_languageModel",
                "index": 0
              }
            ]
          ]
        },
        "Return the whole document": {
          "main": [
            [
              {
                "node": "Create HTML document",
                "type": "main",
                "index": 0
              },
              {
                "node": "Create Markdown Document",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Download PDF from Google Drive": {
          "main": [
            [
              {
                "node": "Merge",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Return each section individually": {
          "main": [
            []
          ]
        },
        "When Executed by Another Workflow": {
          "main": [
            [
              {
                "node": "Download PDF from URL",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Extract Sections headers as fallback": {
          "main": [
            [
              {
                "node": "Table of Content Agent",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "When clicking â€˜Execute workflowâ€™": {
          "main": [
            [
              {
                "node": "Download PDF from Google Drive",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Wait Before Polling the Chunkr Result": {
          "main": [
            [
              {
                "node": "GET Chunkr Task",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Take beginning of Document to look for Table of contents": {
          "main": [
            [
              {
                "node": "Extract Sections headers as fallback",
                "type": "main",
                "index": 0
              }
            ]
          ]
        }
      }
    },
    "lastUpdatedBy": 29,
    "workflowInfo": {
      "nodeCount": 36,
      "nodeTypes": {
        "n8n-nodes-base.set": {
          "count": 1
        },
        "n8n-nodes-base.code": {
          "count": 6
        },
        "n8n-nodes-base.html": {
          "count": 1
        },
        "n8n-nodes-base.wait": {
          "count": 1
        },
        "n8n-nodes-base.merge": {
          "count": 1
        },
        "n8n-nodes-base.switch": {
          "count": 1
        },
        "n8n-nodes-base.stickyNote": {
          "count": 10
        },
        "n8n-nodes-base.googleDrive": {
          "count": 1
        },
        "n8n-nodes-base.httpRequest": {
          "count": 3
        },
        "n8n-nodes-base.stopAndError": {
          "count": 1
        },
        "n8n-nodes-base.convertToFile": {
          "count": 1
        },
        "n8n-nodes-base.manualTrigger": {
          "count": 1
        },
        "n8n-nodes-base.moveBinaryData": {
          "count": 1
        },
        "@n8n/n8n-nodes-langchain.agent": {
          "count": 1
        },
        "n8n-nodes-base.extractFromFile": {
          "count": 1
        },
        "n8n-nodes-base.executeWorkflowTrigger": {
          "count": 1
        },
        "@n8n/n8n-nodes-langchain.lmChatGoogleGemini": {
          "count": 2
        },
        "@n8n/n8n-nodes-langchain.outputParserAutofixing": {
          "count": 1
        },
        "@n8n/n8n-nodes-langchain.outputParserStructured": {
          "count": 1
        }
      }
    },
    "status": "published",
    "user": {
      "name": "Lukas Kunhardt",
      "username": "lukaskunhardt",
      "bio": "Automation Expert with a focus on structured data extraction from messy inputs.",
      "verified": false,
      "links": [
        ""
      ],
      "avatar": "https://gravatar.com/avatar/3e45ac771a72929027267187fc5623b5bfa9ccc330b0af600365c646cc7c3def?r=pg&d=retro&size=200"
    },
    "nodes": [
      {
        "id": 19,
        "icon": "file:httprequest.svg",
        "name": "n8n-nodes-base.httpRequest",
        "codex": {
          "data": {
            "alias": [
              "API",
              "Request",
              "URL",
              "Build",
              "cURL"
            ],
            "resources": {
              "generic": [
                {
                  "url": "https://n8n.io/blog/2021-the-year-to-automate-the-new-you-with-n8n/",
                  "icon": "â˜€ï¸",
                  "label": "2021: The Year to Automate the New You with n8n"
                },
                {
                  "url": "https://n8n.io/blog/why-business-process-automation-with-n8n-can-change-your-daily-life/",
                  "icon": "ðŸ§¬",
                  "label": "Why business process automation with n8n can change your daily life"
                },
                {
                  "url": "https://n8n.io/blog/automatically-pulling-and-visualizing-data-with-n8n/",
                  "icon": "ðŸ“ˆ",
                  "label": "Automatically pulling and visualizing data with n8n"
                },
                {
                  "url": "https://n8n.io/blog/learn-how-to-automatically-cross-post-your-content-with-n8n/",
                  "icon": "âœï¸",
                  "label": "Learn how to automatically cross-post your content with n8n"
                },
                {
                  "url": "https://n8n.io/blog/automatically-adding-expense-receipts-to-google-sheets-with-telegram-mindee-twilio-and-n8n/",
                  "icon": "ðŸ§¾",
                  "label": "Automatically Adding Expense Receipts to Google Sheets with Telegram, Mindee, Twilio, and n8n"
                },
                {
                  "url": "https://n8n.io/blog/running-n8n-on-ships-an-interview-with-maranics/",
                  "icon": "ðŸ›³",
                  "label": "Running n8n on ships: An interview with Maranics"
                },
                {
                  "url": "https://n8n.io/blog/what-are-apis-how-to-use-them-with-no-code/",
                  "icon": " ðŸª¢",
                  "label": "What are APIs and how to use them with no code"
                },
                {
                  "url": "https://n8n.io/blog/5-tasks-you-can-automate-with-notion-api/",
                  "icon": "âš¡ï¸",
                  "label": "5 tasks you can automate with the new Notion API "
                },
                {
                  "url": "https://n8n.io/blog/world-poetry-day-workflow/",
                  "icon": "ðŸ“œ",
                  "label": "Celebrating World Poetry Day with a daily poem in Telegram"
                },
                {
                  "url": "https://n8n.io/blog/automate-google-apps-for-productivity/",
                  "icon": "ðŸ’¡",
                  "label": "15 Google apps you can combine and automate to increase productivity"
                },
                {
                  "url": "https://n8n.io/blog/automate-designs-with-bannerbear-and-n8n/",
                  "icon": "ðŸŽ¨",
                  "label": "Automate Designs with Bannerbear and n8n"
                },
                {
                  "url": "https://n8n.io/blog/how-uproc-scraped-a-multi-page-website-with-a-low-code-workflow/",
                  "icon": " ðŸ•¸ï¸",
                  "label": "How uProc scraped a multi-page website with a low-code workflow"
                },
                {
                  "url": "https://n8n.io/blog/building-an-expense-tracking-app-in-10-minutes/",
                  "icon": "ðŸ“±",
                  "label": "Building an expense tracking app in 10 minutes"
                },
                {
                  "url": "https://n8n.io/blog/5-workflow-automations-for-mattermost-that-we-love-at-n8n/",
                  "icon": "ðŸ¤–",
                  "label": "5 workflow automations for Mattermost that we love at n8n"
                },
                {
                  "url": "https://n8n.io/blog/how-to-use-the-http-request-node-the-swiss-army-knife-for-workflow-automation/",
                  "icon": "ðŸ§°",
                  "label": "How to use the HTTP Request Node - The Swiss Army Knife for Workflow Automation"
                },
                {
                  "url": "https://n8n.io/blog/learn-how-to-use-webhooks-with-mattermost-slash-commands/",
                  "icon": "ðŸ¦„",
                  "label": "Learn how to use webhooks with Mattermost slash commands"
                },
                {
                  "url": "https://n8n.io/blog/how-a-membership-development-manager-automates-his-work-and-investments/",
                  "icon": "ðŸ“ˆ",
                  "label": "How a Membership Development Manager automates his work and investments"
                },
                {
                  "url": "https://n8n.io/blog/a-low-code-bitcoin-ticker-built-with-questdb-and-n8n-io/",
                  "icon": "ðŸ“ˆ",
                  "label": "A low-code bitcoin ticker built with QuestDB and n8n.io"
                },
                {
                  "url": "https://n8n.io/blog/how-to-set-up-a-ci-cd-pipeline-with-no-code/",
                  "icon": "ðŸŽ¡",
                  "label": "How to set up a no-code CI/CD pipeline with GitHub and TravisCI"
                },
                {
                  "url": "https://n8n.io/blog/automations-for-activists/",
                  "icon": "âœ¨",
                  "label": "How Common Knowledge use workflow automation for activism"
                },
                {
                  "url": "https://n8n.io/blog/creating-scheduled-text-affirmations-with-n8n/",
                  "icon": "ðŸ¤Ÿ",
                  "label": "Creating scheduled text affirmations with n8n"
                },
                {
                  "url": "https://n8n.io/blog/how-goomer-automated-their-operations-with-over-200-n8n-workflows/",
                  "icon": "ðŸ›µ",
                  "label": "How Goomer automated their operations with over 200 n8n workflows"
                },
                {
                  "url": "https://n8n.io/blog/aws-workflow-automation/",
                  "label": "7 no-code workflow automations for Amazon Web Services"
                }
              ],
              "primaryDocumentation": [
                {
                  "url": "https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.httprequest/"
                }
              ]
            },
            "categories": [
              "Development",
              "Core Nodes"
            ],
            "nodeVersion": "1.0",
            "codexVersion": "1.0",
            "subcategories": {
              "Core Nodes": [
                "Helpers"
              ]
            }
          }
        },
        "group": "[\"output\"]",
        "defaults": {
          "name": "HTTP Request",
          "color": "#0004F5"
        },
        "iconData": {
          "type": "file",
          "fileBuffer": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00MCAyMEM0MCA4Ljk1MzE0IDMxLjA0NjkgMCAyMCAwQzguOTUzMTQgMCAwIDguOTUzMTQgMCAyMEMwIDMxLjA0NjkgOC45NTMxNCA0MCAyMCA0MEMzMS4wNDY5IDQwIDQwIDMxLjA0NjkgNDAgMjBaTTIwIDM2Ljk0NThDMTguODg1MiAzNi45NDU4IDE3LjEzNzggMzUuOTY3IDE1LjQ5OTggMzIuNjk4NUMxNC43OTY0IDMxLjI5MTggMTQuMTk2MSAyOS41NDMxIDEzLjc1MjYgMjcuNjg0N0gyNi4xODk4QzI1LjgwNDUgMjkuNTQwMyAyNS4yMDQ0IDMxLjI5MDEgMjQuNTAwMiAzMi42OTg1QzIyLjg2MjIgMzUuOTY3IDIxLjExNDggMzYuOTQ1OCAyMCAzNi45NDU4Wk0xMi45MDY0IDIwQzEyLjkwNjQgMjEuNjA5NyAxMy4wMDg3IDIzLjE2NCAxMy4yMDAzIDI0LjYzMDVIMjYuNzk5N0MyNi45OTEzIDIzLjE2NCAyNy4wOTM2IDIxLjYwOTcgMjcuMDkzNiAyMEMyNy4wOTM2IDE4LjM5MDMgMjYuOTkxMyAxNi44MzYgMjYuNzk5NyAxNS4zNjk1SDEzLjIwMDNDMTMuMDA4NyAxNi44MzYgMTIuOTA2NCAxOC4zOTAzIDEyLjkwNjQgMjBaTTIwIDMuMDU0MTlDMjEuMTE0OSAzLjA1NDE5IDIyLjg2MjIgNC4wMzA3OCAyNC41MDAxIDcuMzAwMzlDMjUuMjA2NiA4LjcxNDA4IDI1LjgwNzIgMTAuNDA2NyAyNi4xOTIgMTIuMzE1M0gxMy43NTAxQzE0LjE5MzMgMTAuNDA0NyAxNC43OTQyIDguNzEyNTQgMTUuNDk5OCA3LjMwMDY0QzE3LjEzNzcgNC4wMzA4MyAxOC44ODUxIDMuMDU0MTkgMjAgMy4wNTQxOVpNMzAuMTQ3OCAyMEMzMC4xNDc4IDE4LjQwOTkgMzAuMDU0MyAxNi44NjE3IDI5LjgyMjcgMTUuMzY5NUgzNi4zMDQyQzM2LjcyNTIgMTYuODQyIDM2Ljk0NTggMTguMzk2NCAzNi45NDU4IDIwQzM2Ljk0NTggMjEuNjAzNiAzNi43MjUyIDIzLjE1OCAzNi4zMDQyIDI0LjYzMDVIMjkuODIyN0MzMC4wNTQzIDIzLjEzODMgMzAuMTQ3OCAyMS41OTAxIDMwLjE0NzggMjBaTTI2LjI3NjcgNC4yNTUxMkMyNy42MzY1IDYuMzYwMTkgMjguNzExIDkuMTMyIDI5LjM3NzQgMTIuMzE1M0gzNS4xMDQ2QzMzLjI1MTEgOC42NjggMzAuMTA3IDUuNzgzNDYgMjYuMjc2NyA0LjI1NTEyWk0xMC42MjI2IDEyLjMxNTNINC44OTI5M0M2Ljc1MTQ3IDguNjY3ODQgOS44OTM1MSA1Ljc4MzQxIDEzLjcyMzIgNC4yNTUxM0MxMi4zNjM1IDYuMzYwMjEgMTEuMjg5IDkuMTMyMDEgMTAuNjIyNiAxMi4zMTUzWk0zLjA1NDE5IDIwQzMuMDU0MTkgMjEuNjAzIDMuMjc3NDMgMjMuMTU3NSAzLjY5NDg0IDI0LjYzMDVIMTAuMTIxN0M5Ljk0NjE5IDIzLjE0MiA5Ljg1MjIyIDIxLjU5NDMgOS44NTIyMiAyMEM5Ljg1MjIyIDE4LjQwNTcgOS45NDYxOSAxNi44NTggMTAuMTIxNyAxNS4zNjk1SDMuNjk0ODRDMy4yNzc0MyAxNi44NDI1IDMuMDU0MTkgMTguMzk3IDMuMDU0MTkgMjBaTTI2LjI3NjYgMzUuNzQyN0MyNy42MzY1IDMzLjYzOTMgMjguNzExIDMwLjg2OCAyOS4zNzc0IDI3LjY4NDdIMzUuMTA0NkMzMy4yNTEgMzEuMzMyMiAzMC4xMDY4IDM0LjIxNzkgMjYuMjc2NiAzNS43NDI3Wk0xMy43MjM0IDM1Ljc0MjdDOS44OTM2OSAzNC4yMTc5IDYuNzUxNTUgMzEuMzMyNCA0Ljg5MjkzIDI3LjY4NDdIMTAuNjIyNkMxMS4yODkgMzAuODY4IDEyLjM2MzUgMzMuNjM5MyAxMy43MjM0IDM1Ljc0MjdaIiBmaWxsPSIjM0E0MkU5Ii8+Cjwvc3ZnPgo="
        },
        "displayName": "HTTP Request",
        "typeVersion": 4,
        "nodeCategories": [
          {
            "id": 5,
            "name": "Development"
          },
          {
            "id": 9,
            "name": "Core Nodes"
          }
        ]
      },
      {
        "id": 24,
        "icon": "file:merge.svg",
        "name": "n8n-nodes-base.merge",
        "codex": {
          "data": {
            "alias": [
              "Join",
              "Concatenate",
              "Wait"
            ],
            "resources": {
              "generic": [
                {
                  "url": "https://n8n.io/blog/how-to-sync-data-between-two-systems/",
                  "icon": "ðŸ¬",
                  "label": "How to synchronize data between two systems (one-way vs. two-way sync"
                },
                {
                  "url": "https://n8n.io/blog/supercharging-your-conference-registration-process-with-n8n/",
                  "icon": "ðŸŽ«",
                  "label": "Supercharging your conference registration process with n8n"
                },
                {
                  "url": "https://n8n.io/blog/migrating-community-metrics-to-orbit-using-n8n/",
                  "icon": "ðŸ“ˆ",
                  "label": "Migrating Community Metrics to Orbit using n8n"
                },
                {
                  "url": "https://n8n.io/blog/build-your-own-virtual-assistant-with-n8n-a-step-by-step-guide/",
                  "icon": "ðŸ‘¦",
                  "label": "Build your own virtual assistant with n8n: A step by step guide"
                },
                {
                  "url": "https://n8n.io/blog/sending-automated-congratulations-with-google-sheets-twilio-and-n8n/",
                  "icon": "ðŸ™Œ",
                  "label": "Sending Automated Congratulations with Google Sheets, Twilio, and n8n "
                },
                {
                  "url": "https://n8n.io/blog/aws-workflow-automation/",
                  "label": "7 no-code workflow automations for Amazon Web Services"
                }
              ],
              "primaryDocumentation": [
                {
                  "url": "https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.merge/"
                }
              ]
            },
            "categories": [
              "Core Nodes"
            ],
            "nodeVersion": "1.0",
            "codexVersion": "1.0",
            "subcategories": {
              "Core Nodes": [
                "Flow",
                "Data Transformation"
              ]
            }
          }
        },
        "group": "[\"transform\"]",
        "defaults": {
          "name": "Merge"
        },
        "iconData": {
          "type": "file",
          "fileBuffer": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF8xMTc3XzUxOCkiPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTAgNDhDMCAyMS40OTAzIDIxLjQ5MDMgMCA0OCAwSDExMkMxMzguNTEgMCAxNjAgMjEuNDkwMyAxNjAgNDhWNTZIMTk2LjI1MkMyNDAuNDM1IDU2IDI3Ni4yNTIgOTEuODE3MiAyNzYuMjUyIDEzNlYxOTJDMjc2LjI1MiAyMTQuMDkxIDI5NC4xNjEgMjMyIDMxNi4yNTIgMjMySDM1MlYyMjRDMzUyIDE5Ny40OSAzNzMuNDkgMTc2IDQwMCAxNzZINDY0QzQ5MC41MSAxNzYgNTEyIDE5Ny40OSA1MTIgMjI0VjI4OEM1MTIgMzE0LjUxIDQ5MC41MSAzMzYgNDY0IDMzNkg0MDBDMzczLjQ5IDMzNiAzNTIgMzE0LjUxIDM1MiAyODhWMjgwSDMxNi4yNTJDMjk0LjE2MSAyODAgMjc2LjI1MiAyOTcuOTA5IDI3Ni4yNTIgMzIwVjM3NkMyNzYuMjUyIDQyMC4xODMgMjQwLjQzNSA0NTYgMTk2LjI1MiA0NTZIMTYwVjQ2NEMxNjAgNDkwLjUxIDEzOC41MSA1MTIgMTEyIDUxMkg0OEMyMS40OTAzIDUxMiAwIDQ5MC41MSAwIDQ2NFY0MDBDMCAzNzMuNDkgMjEuNDkwMyAzNTIgNDggMzUySDExMkMxMzguNTEgMzUyIDE2MCAzNzMuNDkgMTYwIDQwMFY0MDhIMTk2LjI1MkMyMTMuOTI1IDQwOCAyMjguMjUyIDM5My42NzMgMjI4LjI1MiAzNzZWMzIwQzIyOC4yNTIgMjk0Ljc4NCAyMzguODU5IDI3Mi4wNDQgMjU1Ljg1MyAyNTZDMjM4Ljg1OSAyMzkuOTU2IDIyOC4yNTIgMjE3LjIxNiAyMjguMjUyIDE5MlYxMzZDMjI4LjI1MiAxMTguMzI3IDIxMy45MjUgMTA0IDE5Ni4yNTIgMTA0SDE2MFYxMTJDMTYwIDEzOC41MSAxMzguNTEgMTYwIDExMiAxNjBINDhDMjEuNDkwMyAxNjAgMCAxMzguNTEgMCAxMTJWNDhaTTEwNCA0OEMxMDguNDE4IDQ4IDExMiA1MS41ODE3IDExMiA1NlYxMDRDMTEyIDEwOC40MTggMTA4LjQxOCAxMTIgMTA0IDExMkg1NkM1MS41ODE3IDExMiA0OCAxMDguNDE4IDQ4IDEwNFY1NkM0OCA1MS41ODE3IDUxLjU4MTcgNDggNTYgNDhIMTA0Wk00NTYgMjI0QzQ2MC40MTggMjI0IDQ2NCAyMjcuNTgyIDQ2NCAyMzJWMjgwQzQ2NCAyODQuNDE4IDQ2MC40MTggMjg4IDQ1NiAyODhINDA4QzQwMy41ODIgMjg4IDQwMCAyODQuNDE4IDQwMCAyODBWMjMyQzQwMCAyMjcuNTgyIDQwMy41ODIgMjI0IDQwOCAyMjRINDU2Wk0xMTIgNDA4QzExMiA0MDMuNTgyIDEwOC40MTggNDAwIDEwNCA0MDBINTZDNTEuNTgxNyA0MDAgNDggNDAzLjU4MiA0OCA0MDhWNDU2QzQ4IDQ2MC40MTggNTEuNTgxNyA0NjQgNTYgNDY0SDEwNEMxMDguNDE4IDQ2NCAxMTIgNDYwLjQxOCAxMTIgNDU2VjQwOFoiIGZpbGw9IiM1NEI4QzkiLz4KPC9nPgo8ZGVmcz4KPGNsaXBQYXRoIGlkPSJjbGlwMF8xMTc3XzUxOCI+CjxyZWN0IHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIiBmaWxsPSJ3aGl0ZSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo="
        },
        "displayName": "Merge",
        "typeVersion": 3,
        "nodeCategories": [
          {
            "id": 9,
            "name": "Core Nodes"
          }
        ]
      },
      {
        "id": 38,
        "icon": "fa:pen",
        "name": "n8n-nodes-base.set",
        "codex": {
          "data": {
            "alias": [
              "Set",
              "JS",
              "JSON",
              "Filter",
              "Transform",
              "Map"
            ],
            "resources": {
              "generic": [
                {
                  "url": "https://n8n.io/blog/learn-to-automate-your-factorys-incident-reporting-a-step-by-step-guide/",
                  "icon": "ðŸ­",
                  "label": "Learn to Automate Your Factory's Incident Reporting: A Step by Step Guide"
                },
                {
                  "url": "https://n8n.io/blog/2021-the-year-to-automate-the-new-you-with-n8n/",
                  "icon": "â˜€ï¸",
                  "label": "2021: The Year to Automate the New You with n8n"
                },
                {
                  "url": "https://n8n.io/blog/automatically-pulling-and-visualizing-data-with-n8n/",
                  "icon": "ðŸ“ˆ",
                  "label": "Automatically pulling and visualizing data with n8n"
                },
                {
                  "url": "https://n8n.io/blog/database-monitoring-and-alerting-with-n8n/",
                  "icon": "ðŸ“¡",
                  "label": "Database Monitoring and Alerting with n8n"
                },
                {
                  "url": "https://n8n.io/blog/automatically-adding-expense-receipts-to-google-sheets-with-telegram-mindee-twilio-and-n8n/",
                  "icon": "ðŸ§¾",
                  "label": "Automatically Adding Expense Receipts to Google Sheets with Telegram, Mindee, Twilio, and n8n"
                },
                {
                  "url": "https://n8n.io/blog/no-code-ecommerce-workflow-automations/",
                  "icon": "store",
                  "label": "6 e-commerce workflows to power up your Shopify s"
                },
                {
                  "url": "https://n8n.io/blog/how-to-build-a-low-code-self-hosted-url-shortener/",
                  "icon": "ðŸ”—",
                  "label": "How to build a low-code, self-hosted URL shortener in 3 steps"
                },
                {
                  "url": "https://n8n.io/blog/automate-your-data-processing-pipeline-in-9-steps-with-n8n/",
                  "icon": "âš™ï¸",
                  "label": "Automate your data processing pipeline in 9 steps"
                },
                {
                  "url": "https://n8n.io/blog/how-to-get-started-with-crm-automation-and-no-code-workflow-ideas/",
                  "icon": "ðŸ‘¥",
                  "label": "How to get started with CRM automation (with 3 no-code workflow ideas"
                },
                {
                  "url": "https://n8n.io/blog/5-tasks-you-can-automate-with-notion-api/",
                  "icon": "âš¡ï¸",
                  "label": "5 tasks you can automate with the new Notion API "
                },
                {
                  "url": "https://n8n.io/blog/automate-google-apps-for-productivity/",
                  "icon": "ðŸ’¡",
                  "label": "15 Google apps you can combine and automate to increase productivity"
                },
                {
                  "url": "https://n8n.io/blog/how-uproc-scraped-a-multi-page-website-with-a-low-code-workflow/",
                  "icon": " ðŸ•¸ï¸",
                  "label": "How uProc scraped a multi-page website with a low-code workflow"
                },
                {
                  "url": "https://n8n.io/blog/building-an-expense-tracking-app-in-10-minutes/",
                  "icon": "ðŸ“±",
                  "label": "Building an expense tracking app in 10 minutes"
                },
                {
                  "url": "https://n8n.io/blog/the-ultimate-guide-to-automate-your-video-collaboration-with-whereby-mattermost-and-n8n/",
                  "icon": "ðŸ“¹",
                  "label": "The ultimate guide to automate your video collaboration with Whereby, Mattermost, and n8n"
                },
                {
                  "url": "https://n8n.io/blog/5-workflow-automations-for-mattermost-that-we-love-at-n8n/",
                  "icon": "ðŸ¤–",
                  "label": "5 workflow automations for Mattermost that we love at n8n"
                },
                {
                  "url": "https://n8n.io/blog/learn-to-build-powerful-api-endpoints-using-webhooks/",
                  "icon": "ðŸ§°",
                  "label": "Learn to Build Powerful API Endpoints Using Webhooks"
                },
                {
                  "url": "https://n8n.io/blog/how-a-membership-development-manager-automates-his-work-and-investments/",
                  "icon": "ðŸ“ˆ",
                  "label": "How a Membership Development Manager automates his work and investments"
                },
                {
                  "url": "https://n8n.io/blog/a-low-code-bitcoin-ticker-built-with-questdb-and-n8n-io/",
                  "icon": "ðŸ“ˆ",
                  "label": "A low-code bitcoin ticker built with QuestDB and n8n.io"
                },
                {
                  "url": "https://n8n.io/blog/how-to-set-up-a-ci-cd-pipeline-with-no-code/",
                  "icon": "ðŸŽ¡",
                  "label": "How to set up a no-code CI/CD pipeline with GitHub and TravisCI"
                },
                {
                  "url": "https://n8n.io/blog/benefits-of-automation-and-n8n-an-interview-with-hubspots-hugh-durkin/",
                  "icon": "ðŸŽ–",
                  "label": "Benefits of automation and n8n: An interview with HubSpot's Hugh Durkin"
                },
                {
                  "url": "https://n8n.io/blog/how-goomer-automated-their-operations-with-over-200-n8n-workflows/",
                  "icon": "ðŸ›µ",
                  "label": "How Goomer automated their operations with over 200 n8n workflows"
                },
                {
                  "url": "https://n8n.io/blog/aws-workflow-automation/",
                  "label": "7 no-code workflow automations for Amazon Web Services"
                }
              ],
              "primaryDocumentation": [
                {
                  "url": "https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.set/"
                }
              ]
            },
            "categories": [
              "Core Nodes"
            ],
            "nodeVersion": "1.0",
            "codexVersion": "1.0",
            "subcategories": {
              "Core Nodes": [
                "Data Transformation"
              ]
            }
          }
        },
        "group": "[\"input\"]",
        "defaults": {
          "name": "Edit Fields"
        },
        "iconData": {
          "icon": "pen",
          "type": "icon"
        },
        "displayName": "Edit Fields (Set)",
        "typeVersion": 3,
        "nodeCategories": [
          {
            "id": 9,
            "name": "Core Nodes"
          }
        ]
      },
      {
        "id": 58,
        "icon": "file:googleDrive.svg",
        "name": "n8n-nodes-base.googleDrive",
        "codex": {
          "data": {
            "resources": {
              "generic": [
                {
                  "url": "https://n8n.io/blog/your-business-doesnt-need-you-to-operate/",
                  "icon": " ðŸ–¥ï¸",
                  "label": "Hey founders! Your business doesn't need you to operate"
                },
                {
                  "url": "https://n8n.io/blog/why-this-product-manager-loves-workflow-automation-with-n8n/",
                  "icon": "ðŸ§ ",
                  "label": "Why this Product Manager loves workflow automation with n8n"
                },
                {
                  "url": "https://n8n.io/blog/aws-workflow-automation/",
                  "label": "7 no-code workflow automations for Amazon Web Services"
                }
              ],
              "primaryDocumentation": [
                {
                  "url": "https://docs.n8n.io/integrations/builtin/app-nodes/n8n-nodes-base.googledrive/"
                }
              ],
              "credentialDocumentation": [
                {
                  "url": "https://docs.n8n.io/integrations/builtin/credentials/google/oauth-single-service/"
                }
              ]
            },
            "categories": [
              "Data & Storage"
            ],
            "nodeVersion": "1.0",
            "codexVersion": "1.0"
          }
        },
        "group": "[\"input\"]",
        "defaults": {
          "name": "Google Drive"
        },
        "iconData": {
          "type": "file",
          "fileBuffer": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBmaWxsPSIjZmZmIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiB2aWV3Qm94PSIwIDAgODEgNzMiPjx1c2UgeGxpbms6aHJlZj0iI2EiIHg9Ii41IiB5PSIuNSIvPjxzeW1ib2wgaWQ9ImEiIG92ZXJmbG93PSJ2aXNpYmxlIj48ZyBmaWxsLXJ1bGU9Im5vbnplcm8iIHN0cm9rZT0ibm9uZSI+PHBhdGggZmlsbD0iIzAwNjZkYSIgZD0ibTYuMDQ4IDYxLjI2IDMuNTI4IDYuMDk0Yy43MzMgMS4yODMgMS43ODcgMi4yOTEgMy4wMjQgMy4wMjRsMTIuNi0yMS44MUgwYTguMyA4LjMgMCAwIDAgMS4xIDQuMTI0eiIvPjxwYXRoIGZpbGw9IiMwMGFjNDciIGQ9Ik00MCAyMi45MSAyNy40IDEuMWMtMS4yMzcuNzMzLTIuMjkxIDEuNzQxLTMuMDI0IDMuMDI0TDEuMSA0NC40NDVBOC4zIDguMyAwIDAgMCAwIDQ4LjU2OGgyNS4yeiIvPjxwYXRoIGZpbGw9IiNlYTQzMzUiIGQ9Ik02Ny40IDcwLjM3OGMxLjIzNy0uNzMzIDIuMjkxLTEuNzQxIDMuMDI0LTMuMDI0bDEuNDY2LTIuNTIgNy4wMS0xMi4xNDJhOC4zIDguMyAwIDAgMCAxLjEtNC4xMjRINTQuNzk4bDUuMzYzIDEwLjUzOHoiLz48cGF0aCBmaWxsPSIjMDA4MzJkIiBkPSJNNDAgMjIuOTEgNTIuNiAxLjFDNTEuMzYzLjM2NyA0OS45NDMgMCA0OC40NzcgMEgzMS41MjRjLTEuNDY2IDAtMi44ODcuNDEyLTQuMTI0IDEuMXoiLz48cGF0aCBmaWxsPSIjMjY4NGZjIiBkPSJNNTQuNzk5IDQ4LjU2OEgyNS4ybC0xMi42IDIxLjgxYzEuMjM3LjczMyAyLjY1NyAxLjEgNC4xMjQgMS4xaDQ2LjU1MmMxLjQ2NiAwIDIuODg3LS40MTIgNC4xMjQtMS4xeiIvPjxwYXRoIGZpbGw9IiNmZmJhMDAiIGQ9Ik02Ny4yNjIgMjQuMjg0IDU1LjYyNCA0LjEyNEM1NC44OTEgMi44NDEgNTMuODM3IDEuODMzIDUyLjYgMS4xTDQwIDIyLjkxbDE0LjggMjUuNjU5aDI1LjE1NWE4LjMgOC4zIDAgMCAwLTEuMS00LjEyNHoiLz48L2c+PC9zeW1ib2w+PC9zdmc+"
        },
        "displayName": "Google Drive",
        "typeVersion": 3,
        "nodeCategories": [
          {
            "id": 3,
            "name": "Data & Storage"
          }
        ]
      },
      {
        "id": 62,
        "icon": "fa:exchange-alt",
        "name": "n8n-nodes-base.moveBinaryData",
        "codex": {
          "data": {
            "alias": [
              "Move Binary Data"
            ],
            "resources": {
              "primaryDocumentation": [
                {
                  "url": "https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.converttofile/"
                }
              ]
            },
            "categories": [
              "Core Nodes"
            ],
            "nodeVersion": "1.0",
            "codexVersion": "1.0",
            "subcategories": {
              "Core Nodes": [
                "Files"
              ]
            }
          }
        },
        "group": "[\"transform\"]",
        "defaults": {
          "name": "Convert to/from binary data",
          "color": "#7722CC"
        },
        "iconData": {
          "icon": "exchange-alt",
          "type": "icon"
        },
        "displayName": "Convert to/from binary data",
        "typeVersion": 1,
        "nodeCategories": [
          {
            "id": 9,
            "name": "Core Nodes"
          }
        ]
      },
      {
        "id": 112,
        "icon": "fa:map-signs",
        "name": "n8n-nodes-base.switch",
        "codex": {
          "data": {
            "alias": [
              "Router",
              "If",
              "Path",
              "Filter",
              "Condition",
              "Logic",
              "Branch",
              "Case"
            ],
            "resources": {
              "generic": [
                {
                  "url": "https://n8n.io/blog/2021-the-year-to-automate-the-new-you-with-n8n/",
                  "icon": "â˜€ï¸",
                  "label": "2021: The Year to Automate the New You with n8n"
                },
                {
                  "url": "https://n8n.io/blog/how-to-get-started-with-crm-automation-and-no-code-workflow-ideas/",
                  "icon": "ðŸ‘¥",
                  "label": "How to get started with CRM automation (with 3 no-code workflow ideas"
                },
                {
                  "url": "https://n8n.io/blog/build-your-own-virtual-assistant-with-n8n-a-step-by-step-guide/",
                  "icon": "ðŸ‘¦",
                  "label": "Build your own virtual assistant with n8n: A step by step guide"
                },
                {
                  "url": "https://n8n.io/blog/automation-for-maintainers-of-open-source-projects/",
                  "icon": "ðŸ·ï¸",
                  "label": "How to automatically manage contributions to open-source projects"
                }
              ],
              "primaryDocumentation": [
                {
                  "url": "https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.switch/"
                }
              ]
            },
            "categories": [
              "Core Nodes"
            ],
            "nodeVersion": "1.0",
            "codexVersion": "1.0",
            "subcategories": {
              "Core Nodes": [
                "Flow"
              ]
            }
          }
        },
        "group": "[\"transform\"]",
        "defaults": {
          "name": "Switch",
          "color": "#506000"
        },
        "iconData": {
          "icon": "map-signs",
          "type": "icon"
        },
        "displayName": "Switch",
        "typeVersion": 3,
        "nodeCategories": [
          {
            "id": 9,
            "name": "Core Nodes"
          }
        ]
      },
      {
        "id": 514,
        "icon": "fa:pause-circle",
        "name": "n8n-nodes-base.wait",
        "codex": {
          "data": {
            "alias": [
              "pause",
              "sleep",
              "delay",
              "timeout"
            ],
            "resources": {
              "generic": [
                {
                  "url": "https://n8n.io/blog/how-to-get-started-with-crm-automation-and-no-code-workflow-ideas/",
                  "icon": "ðŸ‘¥",
                  "label": "How to get started with CRM automation (with 3 no-code workflow ideas"
                },
                {
                  "url": "https://n8n.io/blog/aws-workflow-automation/",
                  "label": "7 no-code workflow automations for Amazon Web Services"
                }
              ],
              "primaryDocumentation": [
                {
                  "url": "https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.wait/"
                }
              ]
            },
            "categories": [
              "Core Nodes"
            ],
            "nodeVersion": "1.0",
            "codexVersion": "1.0",
            "subcategories": {
              "Core Nodes": [
                "Helpers",
                "Flow"
              ]
            }
          }
        },
        "group": "[\"organization\"]",
        "defaults": {
          "name": "Wait",
          "color": "#804050"
        },
        "iconData": {
          "icon": "pause-circle",
          "type": "icon"
        },
        "displayName": "Wait",
        "typeVersion": 1,
        "nodeCategories": [
          {
            "id": 9,
            "name": "Core Nodes"
          }
        ]
      },
      {
        "id": 528,
        "icon": "fa:exclamation-triangle",
        "name": "n8n-nodes-base.stopAndError",
        "codex": {
          "data": {
            "alias": [
              "Throw error",
              "Error",
              "Exception"
            ],
            "resources": {
              "primaryDocumentation": [
                {
                  "url": "https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.stopanderror/"
                }
              ]
            },
            "categories": [
              "Core Nodes",
              "Utility"
            ],
            "nodeVersion": "1.0",
            "codexVersion": "1.0",
            "subcategories": {
              "Core Nodes": [
                "Flow"
              ]
            }
          }
        },
        "group": "[\"input\"]",
        "defaults": {
          "name": "Stop and Error",
          "color": "#ff0000"
        },
        "iconData": {
          "icon": "exclamation-triangle",
          "type": "icon"
        },
        "displayName": "Stop and Error",
        "typeVersion": 1,
        "nodeCategories": [
          {
            "id": 7,
            "name": "Utility"
          },
          {
            "id": 9,
            "name": "Core Nodes"
          }
        ]
      },
      {
        "id": 565,
        "icon": "fa:sticky-note",
        "name": "n8n-nodes-base.stickyNote",
        "codex": {
          "data": {
            "alias": [
              "Comments",
              "Notes",
              "Sticky"
            ],
            "categories": [
              "Core Nodes"
            ],
            "nodeVersion": "1.0",
            "codexVersion": "1.0",
            "subcategories": {
              "Core Nodes": [
                "Helpers"
              ]
            }
          }
        },
        "group": "[\"input\"]",
        "defaults": {
          "name": "Sticky Note",
          "color": "#FFD233"
        },
        "iconData": {
          "icon": "sticky-note",
          "type": "icon"
        },
        "displayName": "Sticky Note",
        "typeVersion": 1,
        "nodeCategories": [
          {
            "id": 9,
            "name": "Core Nodes"
          }
        ]
      },
      {
        "id": 834,
        "icon": "file:code.svg",
        "name": "n8n-nodes-base.code",
        "codex": {
          "data": {
            "alias": [
              "cpde",
              "Javascript",
              "JS",
              "Python",
              "Script",
              "Custom Code",
              "Function"
            ],
            "details": "The Code node allows you to execute JavaScript in your workflow.",
            "resources": {
              "primaryDocumentation": [
                {
                  "url": "https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.code/"
                }
              ]
            },
            "categories": [
              "Development",
              "Core Nodes"
            ],
            "nodeVersion": "1.0",
            "codexVersion": "1.0",
            "subcategories": {
              "Core Nodes": [
                "Helpers",
                "Data Transformation"
              ]
            }
          }
        },
        "group": "[\"transform\"]",
        "defaults": {
          "name": "Code"
        },
        "iconData": {
          "type": "file",
          "fileBuffer": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF8xMTcxXzQ0MSkiPgo8cGF0aCBkPSJNMTcwLjI4MyA0OEgxOTYuNUMyMDMuMTI3IDQ4IDIwOC41IDQyLjYyNzQgMjA4LjUgMzZWMTJDMjA4LjUgNS4zNzI1OCAyMDMuMTI3IDAgMTk2LjUgMEgxNzAuMjgzQzEyNi4xIDAgOTAuMjgzIDM1LjgxNzIgOTAuMjgzIDgwVjE3NkM5MC4yODMgMjA2LjkyOCA2NS4yMTA5IDIzMiAzNC4yODMgMjMySDIzQzE2LjM3MjYgMjMyIDExIDIzNy4zNzIgMTEgMjQ0VjI2OEMxMSAyNzQuNjI3IDE2LjM3MjQgMjgwIDIyLjk5OTYgMjgwTDM0LjI4MyAyODBDNjUuMjEwOSAyODAgOTAuMjgzIDMwNS4wNzIgOTAuMjgzIDMzNlY0NDBDOTAuMjgzIDQ3OS43NjQgMTIyLjUxOCA1MTIgMTYyLjI4MyA1MTJIMTk2LjVDMjAzLjEyNyA1MTIgMjA4LjUgNTA2LjYyNyAyMDguNSA1MDBWNDc2QzIwOC41IDQ2OS4zNzMgMjAzLjEyNyA0NjQgMTk2LjUgNDY0SDE2Mi4yODNDMTQ5LjAyOCA0NjQgMTM4LjI4MyA0NTMuMjU1IDEzOC4yODMgNDQwVjMzNkMxMzguMjgzIDMwOS4wMjIgMTI4LjAxMSAyODQuNDQzIDExMS4xNjQgMjY1Ljk2MUMxMDYuMTA5IDI2MC40MTYgMTA2LjEwOSAyNTEuNTg0IDExMS4xNjQgMjQ2LjAzOUMxMjguMDExIDIyNy41NTcgMTM4LjI4MyAyMDIuOTc4IDEzOC4yODMgMTc2VjgwQzEzOC4yODMgNjIuMzI2OSAxNTIuNjEgNDggMTcwLjI4MyA0OFoiIGZpbGw9IiNGRjk5MjIiLz4KPHBhdGggZD0iTTMwNSAzNkMzMDUgNDIuNjI3NCAzMTAuMzczIDQ4IDMxNyA0OEgzNDIuOTc5QzM2MC42NTIgNDggMzc0Ljk3OCA2Mi4zMjY5IDM3NC45NzggODBWMTc2QzM3NC45NzggMjAyLjk3OCAzODUuMjUxIDIyNy41NTcgNDAyLjA5OCAyNDYuMDM5QzQwNy4xNTMgMjUxLjU4NCA0MDcuMTUzIDI2MC40MTYgNDAyLjA5OCAyNjUuOTYxQzM4NS4yNTEgMjg0LjQ0MyAzNzQuOTc4IDMwOS4wMjIgMzc0Ljk3OCAzMzZWNDMyQzM3NC45NzggNDQ5LjY3MyAzNjAuNjUyIDQ2NCAzNDIuOTc5IDQ2NEgzMTdDMzEwLjM3MyA0NjQgMzA1IDQ2OS4zNzMgMzA1IDQ3NlY1MDBDMzA1IDUwNi42MjcgMzEwLjM3MyA1MTIgMzE3IDUxMkgzNDIuOTc5QzM4Ny4xNjEgNTEyIDQyMi45NzggNDc2LjE4MyA0MjIuOTc4IDQzMlYzMzZDNDIyLjk3OCAzMDUuMDcyIDQ0OC4wNTEgMjgwIDQ3OC45NzkgMjgwSDQ5MEM0OTYuNjI3IDI4MCA1MDIgMjc0LjYyOCA1MDIgMjY4VjI0NEM1MDIgMjM3LjM3MyA0OTYuNjI4IDIzMiA0OTAgMjMyTDQ3OC45NzkgMjMyQzQ0OC4wNTEgMjMyIDQyMi45NzggMjA2LjkyOCA0MjIuOTc4IDE3NlY4MEM0MjIuOTc4IDM1LjgxNzIgMzg3LjE2MSAwIDM0Mi45NzkgMEgzMTdDMzEwLjM3MyAwIDMwNSA1LjM3MjU4IDMwNSAxMlYzNloiIGZpbGw9IiNGRjk5MjIiLz4KPC9nPgo8ZGVmcz4KPGNsaXBQYXRoIGlkPSJjbGlwMF8xMTcxXzQ0MSI+CjxyZWN0IHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIiBmaWxsPSJ3aGl0ZSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo="
        },
        "displayName": "Code",
        "typeVersion": 2,
        "nodeCategories": [
          {
            "id": 5,
            "name": "Development"
          },
          {
            "id": 9,
            "name": "Core Nodes"
          }
        ]
      },
      {
        "id": 837,
        "icon": "fa:sign-out-alt",
        "name": "n8n-nodes-base.executeWorkflowTrigger",
        "codex": {
          "data": {
            "resources": {
              "generic": [],
              "primaryDocumentation": [
                {
                  "url": "https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.executeworkflowtrigger/"
                }
              ]
            },
            "categories": [
              "Core Nodes"
            ],
            "nodeVersion": "1.0",
            "codexVersion": "1.0",
            "subcategories": {
              "Core Nodes": [
                "Helpers"
              ]
            }
          }
        },
        "group": "[\"trigger\"]",
        "defaults": {
          "name": "When Executed by Another Workflow",
          "color": "#ff6d5a"
        },
        "iconData": {
          "icon": "sign-out-alt",
          "type": "icon"
        },
        "displayName": "Execute Workflow Trigger",
        "typeVersion": 1,
        "nodeCategories": [
          {
            "id": 9,
            "name": "Core Nodes"
          }
        ]
      },
      {
        "id": 838,
        "icon": "fa:mouse-pointer",
        "name": "n8n-nodes-base.manualTrigger",
        "codex": {
          "data": {
            "resources": {
              "generic": [],
              "primaryDocumentation": [
                {
                  "url": "https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.manualworkflowtrigger/"
                }
              ]
            },
            "categories": [
              "Core Nodes"
            ],
            "nodeVersion": "1.0",
            "codexVersion": "1.0"
          }
        },
        "group": "[\"trigger\"]",
        "defaults": {
          "name": "When clicking â€˜Execute workflowâ€™",
          "color": "#909298"
        },
        "iconData": {
          "icon": "mouse-pointer",
          "type": "icon"
        },
        "displayName": "Manual Trigger",
        "typeVersion": 1,
        "nodeCategories": [
          {
            "id": 9,
            "name": "Core Nodes"
          }
        ]
      },
      {
        "id": 842,
        "icon": "file:html.svg",
        "name": "n8n-nodes-base.html",
        "codex": {
          "data": {
            "alias": [
              "extract",
              "template",
              "table"
            ],
            "resources": {
              "primaryDocumentation": [
                {
                  "url": "https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.html/"
                }
              ]
            },
            "categories": [
              "Core Nodes"
            ],
            "nodeVersion": "1.0",
            "codexVersion": "1.0",
            "subcategories": {
              "Core Nodes": [
                "Data Transformation"
              ]
            }
          }
        },
        "group": "[\"transform\"]",
        "defaults": {
          "name": "HTML"
        },
        "iconData": {
          "type": "file",
          "fileBuffer": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTguNjQwNjIgMEgxMC40Mzc1VjEuNzgxMjVIMTIuMDkzN1YwSDEzLjg5MDZWNS4zOTA2MkgxMi4wOTM3VjMuNTkzNzVIMTAuNDUzMVY1LjM5MDYySDguNjQwNjJNMTYuMjY1NiAxLjc5Njg3SDE0LjY3OTdWMEgxOS42NTYyVjEuNzk2ODdIMTguMDYyNVY1LjM5MDYySDE2LjI2NTZNMjAuNDQ1MyAwSDIyLjMyODFMMjMuNDg0NCAxLjg5ODQ0TDI0LjY0MDYgMEgyNi41MjM0VjUuMzkwNjJIMjQuNzI2NlYyLjcxODc1TDIzLjQ2ODcgNC42NTYyNUwyMi4yMTA5IDIuNzE4NzVWNS4zOTA2MkgyMC40NDUzTTI3LjQxNDEgMEgyOS4yMTA5VjMuNjA5MzdIMzEuNzU3OFY1LjM5MDYySDI3LjQxNDEiIGZpbGw9ImJsYWNrIi8+CjxwYXRoIGQ9Ik04LjU3ODEyIDM2Ljc5NjlMNiA3Ljg1OTM4SDM0LjM0MzdMMzEuNzY1NiAzNi43ODEyTDIwLjE0ODQgNDAiIGZpbGw9IiNFNDREMjYiLz4KPHBhdGggZD0iTTIwLjE3MTkgMzcuNTM5MVYxMC4yMzQ0SDMxLjc1NzhMMjkuNTQ2OSAzNC45MjE5IiBmaWxsPSIjRjE2NTI5Ii8+CjxwYXRoIGQ9Ik0xMS4yNjU2IDEzLjc3MzRIMjAuMTcxOVYxNy4zMjAzSDE1LjE1NjJMMTUuNDg0NCAyMC45NTMxSDIwLjE3MTlWMjQuNDkyMkgxMi4yMzQ0TTEyLjM5MDYgMjYuMjczNEgxNS45NTMxTDE2LjIwMzEgMjkuMTA5NEwyMC4xNzE5IDMwLjE3MTlWMzMuODc1TDEyLjg5MDYgMzEuODQzNyIgZmlsbD0iI0VCRUJFQiIvPgo8cGF0aCBkPSJNMjkuMDQ2OSAxMy43NzM0SDIwLjE1NjJWMTcuMzIwM0gyOC43MTg3TTI4LjM5ODQgMjAuOTUzMUgyMC4xNTYyVjI0LjVIMjQuNTMxMkwyNC4xMTcyIDI5LjEwOTRMMjAuMTU2MiAzMC4xNzE5VjMzLjg1OTRMMjcuNDIxOSAzMS44NDM3IiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K"
        },
        "displayName": "HTML",
        "typeVersion": 1,
        "nodeCategories": [
          {
            "id": 9,
            "name": "Core Nodes"
          }
        ]
      },
      {
        "id": 1119,
        "icon": "fa:robot",
        "name": "@n8n/n8n-nodes-langchain.agent",
        "codex": {
          "data": {
            "alias": [
              "LangChain",
              "Chat",
              "Conversational",
              "Plan and Execute",
              "ReAct",
              "Tools"
            ],
            "resources": {
              "primaryDocumentation": [
                {
                  "url": "https://docs.n8n.io/integrations/builtin/cluster-nodes/root-nodes/n8n-nodes-langchain.agent/"
                }
              ]
            },
            "categories": [
              "AI",
              "Langchain"
            ],
            "subcategories": {
              "AI": [
                "Agents",
                "Root Nodes"
              ]
            }
          }
        },
        "group": "[\"transform\"]",
        "defaults": {
          "name": "AI Agent",
          "color": "#404040"
        },
        "iconData": {
          "icon": "robot",
          "type": "icon"
        },
        "displayName": "AI Agent",
        "typeVersion": 3,
        "nodeCategories": [
          {
            "id": 25,
            "name": "AI"
          },
          {
            "id": 26,
            "name": "Langchain"
          }
        ]
      },
      {
        "id": 1175,
        "icon": "fa:tools",
        "name": "@n8n/n8n-nodes-langchain.outputParserAutofixing",
        "codex": {
          "data": {
            "resources": {
              "primaryDocumentation": [
                {
                  "url": "https://docs.n8n.io/integrations/builtin/cluster-nodes/sub-nodes/n8n-nodes-langchain.outputparserautofixing/"
                }
              ]
            },
            "categories": [
              "AI",
              "Langchain"
            ],
            "subcategories": {
              "AI": [
                "Output Parsers"
              ]
            }
          }
        },
        "group": "[\"transform\"]",
        "defaults": {
          "name": "Auto-fixing Output Parser"
        },
        "iconData": {
          "icon": "tools",
          "type": "icon"
        },
        "displayName": "Auto-fixing Output Parser",
        "typeVersion": 1,
        "nodeCategories": [
          {
            "id": 25,
            "name": "AI"
          },
          {
            "id": 26,
            "name": "Langchain"
          }
        ]
      },
      {
        "id": 1179,
        "icon": "fa:code",
        "name": "@n8n/n8n-nodes-langchain.outputParserStructured",
        "codex": {
          "data": {
            "alias": [
              "json",
              "zod"
            ],
            "resources": {
              "primaryDocumentation": [
                {
                  "url": "https://docs.n8n.io/integrations/builtin/cluster-nodes/sub-nodes/n8n-nodes-langchain.outputparserstructured/"
                }
              ]
            },
            "categories": [
              "AI",
              "Langchain"
            ],
            "subcategories": {
              "AI": [
                "Output Parsers"
              ]
            }
          }
        },
        "group": "[\"transform\"]",
        "defaults": {
          "name": "Structured Output Parser"
        },
        "iconData": {
          "icon": "code",
          "type": "icon"
        },
        "displayName": "Structured Output Parser",
        "typeVersion": 1,
        "nodeCategories": [
          {
            "id": 25,
            "name": "AI"
          },
          {
            "id": 26,
            "name": "Langchain"
          }
        ]
      },
      {
        "id": 1234,
        "icon": "file:convertToFile.svg",
        "name": "n8n-nodes-base.convertToFile",
        "codex": {
          "data": {
            "alias": [
              "CSV",
              "Spreadsheet",
              "Excel",
              "xls",
              "xlsx",
              "ods",
              "tabular",
              "encode",
              "encoding",
              "Move Binary Data",
              "Binary",
              "File",
              "JSON",
              "HTML",
              "ICS",
              "iCal",
              "RTF",
              "64",
              "Base64"
            ],
            "resources": {
              "primaryDocumentation": [
                {
                  "url": "https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.converttofile/"
                }
              ]
            },
            "categories": [
              "Core Nodes"
            ],
            "nodeVersion": "1.0",
            "codexVersion": "1.0",
            "subcategories": {
              "Core Nodes": [
                "Files",
                "Data Transformation"
              ]
            }
          }
        },
        "group": "[\"input\"]",
        "defaults": {
          "name": "Convert to File"
        },
        "iconData": {
          "type": "file",
          "fileBuffer": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTEzLjc2MTkgMkMxMy4yNDM3IDIgMTIuODIzNiAyLjQyMDA5IDEyLjgyMzYgMi45MzgzMVYxNS4yNTI2QzEzLjMxOTkgMTUuNDY0MyAxMy43ODUxIDE1Ljc3MiAxNC4xOTEgMTYuMTc1N0wyMS4yMjgzIDIzLjE3MzlDMjIuMDU0OCAyMy45OTU4IDIyLjUxOTUgMjUuMTEzMiAyMi41MTk1IDI2LjI3ODhDMjIuNTE5NSAyNy40NDQzIDIyLjA1NDggMjguNTYxOCAyMS4yMjgzIDI5LjM4MzdMMTQuMTkxIDM2LjM4MTlDMTMuNzg1IDM2Ljc4NTYgMTMuMzE5OSAzNy4wOTMyIDEyLjgyMzYgMzcuMzA1VjM3LjM1MjdDMTIuODIzNiAzNy44NzA5IDEzLjI0MzcgMzguMjkxIDEzLjc2MTkgMzguMjkxSDM5LjA2MTdDMzkuNTc5OSAzOC4yOTEgNDAgMzcuODcwOSA0MCAzNy4zNTI3TDQwIDE1Ljc5NEgyNy4xNDQzQzI2LjYyNjEgMTUuNzk0IDI2LjIwNiAxNS4zNzM5IDI2LjIwNiAxNC44NTU3VjJIMTMuNzYxOVoiIGZpbGw9IiMzQTQyRTkiLz4KPHBhdGggZD0iTTI4Ljg2NDUgMkMyOC43NzgxIDIgMjguNzA4MSAyLjA3MDAyIDI4LjcwODEgMi4xNTYzOVYxMi44MjI3QzI4LjcwODEgMTMuMDgxOCAyOC45MTgyIDEzLjI5MTkgMjkuMTc3MyAxMy4yOTE5SDM5Ljg0MzZDMzkuOTMgMTMuMjkxOSA0MCAxMy4yMjE5IDQwIDEzLjEzNTVMNDAgMTIuNjI2M0M0MCAxMi4zNzc4IDM5LjkwMTQgMTIuMTM5NSAzOS43MjYgMTEuOTYzNkwzMC4wNjEgMi4yNzU2MUMyOS44ODUgMi4wOTkxNiAyOS42NDYgMiAyOS4zOTY3IDJIMjguODY0NVoiIGZpbGw9IiMzQTQyRTkiLz4KPHBhdGggZD0iTTkuNzcyNjggMzQuNjAwM0M5LjA0MTg2IDMzLjg2NTQgOS4wNDUxNyAzMi42NzcyIDkuNzgwMDcgMzEuOTQ2NEwxMy42MzE1IDI4LjExNjNMMC45MzgzMTEgMjguMTE2M0MwLjQyMDA5NiAyOC4xMTYzIC0yLjI2NTE5ZS0wOCAyNy42OTYyIDAgMjcuMTc4TDguMjAyOTdlLTA4IDI1LjMwMTRDMS4wNDY4MmUtMDcgMjQuNzgzMiAwLjQyMDA5NSAyNC4zNjMxIDAuOTM4MzExIDI0LjM2MzFIMTMuNTUyOUw5Ljc4MDA3IDIwLjYxMTJDOS4wNDUxNyAxOS44ODA0IDkuMDQxODYgMTguNjkyMiA5Ljc3MjY4IDE3Ljk1NzNDMTAuNTAzNSAxNy4yMjI0IDExLjY5MTcgMTcuMjE5MSAxMi40MjY2IDE3Ljk0OTlMMTkuNDYzOSAyNC45NDgxQzE5LjgxODEgMjUuMzAwNCAyMC4wMTczIDI1Ljc3OTMgMjAuMDE3MyAyNi4yNzg4QzIwLjAxNzMgMjYuNzc4MyAxOS44MTgxIDI3LjI1NzIgMTkuNDYzOSAyNy42MDk1TDEyLjQyNjYgMzQuNjA3N0MxMS42OTE3IDM1LjMzODUgMTAuNTAzNSAzNS4zMzUyIDkuNzcyNjggMzQuNjAwM1oiIGZpbGw9IiMzQTQyRTkiLz4KPC9zdmc+Cg=="
        },
        "displayName": "Convert to File",
        "typeVersion": 1,
        "nodeCategories": [
          {
            "id": 9,
            "name": "Core Nodes"
          }
        ]
      },
      {
        "id": 1235,
        "icon": "file:extractFromFile.svg",
        "name": "n8n-nodes-base.extractFromFile",
        "codex": {
          "data": {
            "alias": [
              "CSV",
              "Spreadsheet",
              "Excel",
              "xls",
              "xlsx",
              "ods",
              "tabular",
              "decode",
              "decoding",
              "Move Binary Data",
              "Binary",
              "File",
              "PDF",
              "JSON",
              "HTML",
              "ICS",
              "iCal",
              "txt",
              "Text",
              "RTF",
              "XML",
              "64",
              "Base64",
              "Convert"
            ],
            "resources": {
              "primaryDocumentation": [
                {
                  "url": "https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.extractfromfile/"
                }
              ]
            },
            "categories": [
              "Core Nodes"
            ],
            "nodeVersion": "1.0",
            "codexVersion": "1.0",
            "subcategories": {
              "Core Nodes": [
                "Files",
                "Data Transformation"
              ]
            }
          }
        },
        "group": "[\"input\"]",
        "defaults": {
          "name": "Extract from File"
        },
        "iconData": {
          "type": "file",
          "fileBuffer": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTAuOTM3NSAyQzAuNDE5NzMzIDIgMCAyLjQxOTczIDAgMi45Mzc1VjM3LjMyMjFDMCAzNy44Mzk5IDAuNDE5NzMzIDM4LjI1OTYgMC45Mzc1IDM4LjI1OTZIMjYuMjE1NEMyNi43MzMyIDM4LjI1OTYgMjcuMTUyOSAzNy44Mzk5IDI3LjE1MjkgMzcuMzIyMUwyNy4xNTI5IDMwLjY3MTlMMTYuNzk2OSAzMC42NzE5QzE0Ljg5ODQgMzAuNjcxOSAxMy4zNTk0IDI5LjEzMjkgMTMuMzU5NCAyNy4yMzQ0VjI1LjM1OTRDMTMuMzU5NCAyMy40NjA5IDE0Ljg5ODQgMjEuOTIxOSAxNi43OTY5IDIxLjkyMTlIMjcuMTUyOUwyNy4xNTI5IDE1Ljc4MjFIMTQuMzA4M0MxMy43OTA2IDE1Ljc4MjEgMTMuMzcwOCAxNS4zNjI0IDEzLjM3MDggMTQuODQ0NlYySDAuOTM3NVoiIGZpbGw9IiMzNTNGNkUiLz4KPHBhdGggZD0iTTE2LjAyNzEgMkMxNS45NDA4IDIgMTUuODcwOCAyLjA2OTk2IDE1Ljg3MDggMi4xNTYyNVYxMi44MTM0QzE1Ljg3MDggMTMuMDcyMyAxNi4wODA3IDEzLjI4MjEgMTYuMzM5NiAxMy4yODIxSDI2Ljk5NjdDMjcuMDgzIDEzLjI4MjEgMjcuMTUyOSAxMy4yMTIyIDI3LjE1MjkgMTMuMTI1OUwyNy4xNTI5IDEyLjYxNzFDMjcuMTUyOSAxMi4zNjg4IDI3LjA1NDUgMTIuMTMwNyAyNi44NzkxIDExLjk1NUwxNy4yMjI1IDIuMjc1MzhDMTcuMDQ2NiAyLjA5OTA4IDE2LjgwNzkgMiAxNi41NTg4IDJIMTYuMDI3MVoiIGZpbGw9IiMzNTNGNkUiLz4KPHBhdGggZD0iTTI5Ljc2NDIgMzQuNjUwM0MyOS4wMzQgMzMuOTE2IDI5LjAzNzQgMzIuNzI4OCAyOS43NzE2IDMxLjk5ODZMMzMuNjE5NyAyOC4xNzE5TDE2Ljc5NjkgMjguMTcxOUMxNi4yNzkxIDI4LjE3MTkgMTUuODU5NCAyNy43NTIxIDE1Ljg1OTQgMjcuMjM0NFYyNS4zNTk0QzE1Ljg1OTQgMjQuODQxNiAxNi4yNzkxIDI0LjQyMTkgMTYuNzk2OSAyNC40MjE5TDMzLjU0MTIgMjQuNDIxOUwyOS43NzE2IDIwLjY3MzNDMjkuMDM3NCAxOS45NDMxIDI5LjAzNCAxOC43NTU5IDI5Ljc2NDIgMTguMDIxNkMzMC40OTQ0IDE3LjI4NzQgMzEuNjgxNiAxNy4yODQgMzIuNDE1OSAxOC4wMTQyTDM5LjQ0NzEgMjUuMDA2NEMzOS44MDEgMjUuMzU4MyA0MCAyNS44MzY4IDQwIDI2LjMzNTlDNDAgMjYuODM1IDM5LjgwMSAyNy4zMTM1IDM5LjQ0NzEgMjcuNjY1NUwzMi40MTU5IDM0LjY1NzZDMzEuNjgxNiAzNS4zODc4IDMwLjQ5NDQgMzUuMzg0NSAyOS43NjQyIDM0LjY1MDNaIiBmaWxsPSIjMzUzRjZFIi8+Cjwvc3ZnPgo="
        },
        "displayName": "Extract from File",
        "typeVersion": 1,
        "nodeCategories": [
          {
            "id": 9,
            "name": "Core Nodes"
          }
        ]
      },
      {
        "id": 1262,
        "icon": "file:google.svg",
        "name": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
        "codex": {
          "data": {
            "resources": {
              "primaryDocumentation": [
                {
                  "url": "https://docs.n8n.io/integrations/builtin/cluster-nodes/sub-nodes/n8n-nodes-langchain.lmchatgooglegemini/"
                }
              ]
            },
            "categories": [
              "AI",
              "Langchain"
            ],
            "subcategories": {
              "AI": [
                "Language Models",
                "Root Nodes"
              ],
              "Language Models": [
                "Chat Models (Recommended)"
              ]
            }
          }
        },
        "group": "[\"transform\"]",
        "defaults": {
          "name": "Google Gemini Chat Model"
        },
        "iconData": {
          "type": "file",
          "fileBuffer": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgNDggNDgiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJNNDQuNSAyMEgyNHY4LjVoMTEuOEMzNC43IDMzLjkgMzAuMSAzNyAyNCAzN2MtNy4yIDAtMTMtNS44LTEzLTEzczUuOC0xMyAxMy0xM2MzLjEgMCA1LjkgMS4xIDguMSAyLjlsNi40LTYuNEMzNC42IDQuMSAyOS42IDIgMjQgMiAxMS44IDIgMiAxMS44IDIgMjRzOS44IDIyIDIyIDIyYzExIDAgMjEtOCAyMS0yMiAwLTEuMy0uMi0yLjctLjUtNCIvPjwvZGVmcz48Y2xpcFBhdGggaWQ9ImIiPjx1c2UgeGxpbms6aHJlZj0iI2EiIG92ZXJmbG93PSJ2aXNpYmxlIi8+PC9jbGlwUGF0aD48cGF0aCBmaWxsPSIjRkJCQzA1IiBkPSJNMCAzN1YxMWwxNyAxM3oiIGNsaXAtcGF0aD0idXJsKCNiKSIvPjxwYXRoIGZpbGw9IiNFQTQzMzUiIGQ9Im0wIDExIDE3IDEzIDctNi4xTDQ4IDE0VjBIMHoiIGNsaXAtcGF0aD0idXJsKCNiKSIvPjxwYXRoIGZpbGw9IiMzNEE4NTMiIGQ9Im0wIDM3IDMwLTIzIDcuOSAxTDQ4IDB2NDhIMHoiIGNsaXAtcGF0aD0idXJsKCNiKSIvPjxwYXRoIGZpbGw9IiM0Mjg1RjQiIGQ9Ik00OCA0OCAxNyAyNGwtNC0zIDM1LTEweiIgY2xpcC1wYXRoPSJ1cmwoI2IpIi8+PC9zdmc+"
        },
        "displayName": "Google Gemini Chat Model",
        "typeVersion": 1,
        "nodeCategories": [
          {
            "id": 25,
            "name": "AI"
          },
          {
            "id": 26,
            "name": "Langchain"
          }
        ]
      }
    ],
    "categories": [
      {
        "id": 35,
        "name": "Document Extraction"
      },
      {
        "id": 49,
        "name": "AI Summarization"
      }
    ],
    "image": []
  }
}