{
  "id": 9983,
  "slug": "9983",
  "title": "Auto-categorize blog posts with OpenAI GPT-4, GitHub, and Google Sheets for Astro/Next.js",
  "description": "![image.png](fileId:3102)\n\n## Automatically Assign Categories and Tags to Blog Posts with AI  \n\nThis workflow streamlines your **content organization process** by automatically analyzing new blog posts in your GitHub repository and assigning appropriate **categories** and **tags** using OpenAI. It compares new posts against existing entries in a Google Sheet, updates the metadata for each new article, and records the suggested tags and categories for review — all in one automated pipeline.  \n\n---\n\n## Who’s It For  \n\n- **Content creators and editors** managing a static website (e.g., Astro or Next.js) who want AI-driven tagging.  \n- **SEO specialists** seeking consistent metadata and topic organization.  \n- **Developers or teams** managing a Markdown-based blog stored in GitHub who want to speed up post curation.  \n\n---\n\n## How It Works  \n\n1. **Form Trigger** – Starts the process manually with a form that initiates article analysis.  \n2. **Get Data from Google Sheets** – Retrieves existing post records to prevent duplicate analysis.  \n3. **Compare GitHub and Google Sheets** – Lists all `.md` or `.mdx` blog posts from the GitHub repository (`piotr-sikora.com/src/content/blog/pl/`) and identifies **new posts** not yet analyzed.  \n4. **Check New Repo Files** – Uses a code node to filter only unprocessed files for AI tagging.  \n5. **Switch Node** –  \n   - If there are **no new posts**, the workflow stops and shows a confirmation message.  \n   - If new posts exist, it continues to the next step.  \n6. **Get Post Content from GitHub** – Downloads the content of each new article.  \n7. **AI Agent (LangChain + OpenAI GPT-4.1-mini)** –  \n   - Reads each post’s frontmatter (`---` section) and body.  \n   - Suggests new `categories` and `tags` based on the article’s topic.  \n   - Returns a JSON object with proposed updates (Structured Output Parser)\n8. **Append to Google Sheets** – Logs results, including:  \n   - File name  \n   - Existing tags and categories  \n   - Proposed tags and categories (AI suggestions)  \n9. **Completion Message** – Displays a success message confirming the categorization process has finished.  \n\n---\n\n## Requirements  \n\n- **GitHub account** with repository access to your website content.  \n- **Google Sheets connection** for storing metadata suggestions.  \n- **OpenAI account** (credential stored in `openAiApi`).  \n\n---\n\n## How to Set Up  \n\n1. Connect your **GitHub**, **Google Sheets**, and **OpenAI** credentials in n8n.  \n2. Update the GitHub repository path to match your project (e.g., `src/content/blog/en/`).  \n3. In Google Sheets, create columns:  \n   - `FileName`, `Categories`, `Proposed Categories`, `Tags`, `Proposed Tags`.  \n4. Adjust the AI model or prompt text if you want different tagging behavior.  \n5. Run the workflow manually using the **Form Trigger** node.  \n\n---\n\n## How to Customize  \n\n- Swap **OpenAI GPT-4.1-mini** for another LLM (e.g., Claude or Gemini) via the LangChain node.  \n- Modify the **prompt** in the AI Agent to adapt categorization style or tone.  \n- Add a **GitHub commit node** if you want AI-updated metadata written back to files automatically.  \n- Use the **Schedule Trigger** node to automate this process daily.  \n\n---\n\n## Important Notes  \n\n- All API keys and credentials are securely stored — **no hardcoded keys**.  \n- The workflow includes multiple **sticky notes** explaining:  \n  - Repository setup  \n  - File retrieval and AI tagging  \n  - Google Sheet data structure  \n- It uses a **LangChain memory buffer** to improve contextual consistency during multiple analyses.  \n\n---\n\n## Summary  \n\nThis workflow automates metadata management for blogs or documentation sites by combining **GitHub content**, **AI categorization**, and **Google Sheets tracking**.  \nWith it, you can easily maintain consistent tags and categories across dozens of articles — boosting SEO, readability, and editorial efficiency without manual tagging.\n",
  "featuredImage": "/data/workflows/9983/9983.webp",
  "author": {
    "id": 101,
    "slug": "argone",
    "name": "Piotr Sikora",
    "avatar": ""
  },
  "categories": [
    "Content Creation",
    "AI Summarization"
  ],
  "complexityLevel": "advanced",
  "price": 0,
  "visitors": 193,
  "downloads": 19,
  "createdAt": "2025-10-21T13:58:21.067Z",
  "updatedAt": "2026-01-16T09:02:52.342Z",
  "publishedAt": "2025-10-21T13:58:21.067Z",
  "nodes": 29,
  "version": "1.0.0",
  "sourceUrl": "https://n8n.io/workflows/9983",
  "disclaimer": "This workflow is provided as-is. Please review and test before using in production.",
  "overview": {
    "title": "Auto-categorize blog posts with OpenAI GPT-4, GitHub, and Google Sheets for Astro/Next.js",
    "workflowName": "Auto-categorize blog posts with OpenAI GPT-4, GitHub, and Google Sheets for Astro/Next.js",
    "description": "![image.png](fileId:3102)\n\n## Automatically Assign Categories and Tags to Blog Posts with AI  \n\nThis workflow streamlines your **content organization process** by automatically analyzing new blog posts in your GitHub repository and assigning appropriate **categories** and **tags** using OpenAI. It compares new posts against existing entries in a Google Sheet, updates the metadata for each new article, and records the suggested tags and categories for review — all in one automated pipeline.  \n\n---\n\n## Who’s It For  \n\n- **Content creators and editors** managing a static website (e.g., Astro or Next.js) who want AI-driven tagging.  \n- **SEO specialists** seeking consistent metadata and topic organization.  \n- **Developers or teams** managing a Markdown-based blog stored in GitHub who want to speed up post curation.  \n\n---\n\n## How It Works  \n\n1. **Form Trigger** – Starts the process manually with a form that initiates article analysis.  \n2. **Get Data from Google Sheets** – Retrieves existing post records to prevent duplicate analysis.  \n3. **Compare GitHub and Google Sheets** – Lists all `.md` or `.mdx` blog posts from the GitHub repository (`piotr-sikora.com/src/content/blog/pl/`) and identifies **new posts** not yet analyzed.  \n4. **Check New Repo Files** – Uses a code node to filter only unprocessed files for AI tagging.  \n5. **Switch Node** –  \n   - If there are **no new posts**, the workflow stops and shows a confirmation message.  \n   - If new posts exist, it continues to the next step.  \n6. **Get Post Content from GitHub** – Downloads the content of each new article.  \n7. **AI Agent (LangChain + OpenAI GPT-4.1-mini)** –  \n   - Reads each post’s frontmatter (`---` section) and body.  \n   - Suggests new `categories` and `tags` based on the article’s topic.  \n   - Returns a JSON object with proposed updates (Structured Output Parser)\n8. **Append to Google Sheets** – Logs results, including:  \n   - File name  \n   - Existing tags and categories  \n   - Proposed tags and categories (AI suggestions)  \n9. **Completion Message** – Displays a success message confirming the categorization process has finished.  \n\n---\n\n## Requirements  \n\n- **GitHub account** with repository access to your website content.  \n- **Google Sheets connection** for storing metadata suggestions.  \n- **OpenAI account** (credential stored in `openAiApi`).  \n\n---\n\n## How to Set Up  \n\n1. Connect your **GitHub**, **Google Sheets**, and **OpenAI** credentials in n8n.  \n2. Update the GitHub repository path to match your project (e.g., `src/content/blog/en/`).  \n3. In Google Sheets, create columns:  \n   - `FileName`, `Categories`, `Proposed Categories`, `Tags`, `Proposed Tags`.  \n4. Adjust the AI model or prompt text if you want different tagging behavior.  \n5. Run the workflow manually using the **Form Trigger** node.  \n\n---\n\n## How to Customize  \n\n- Swap **OpenAI GPT-4.1-mini** for another LLM (e.g., Claude or Gemini) via the LangChain node.  \n- Modify the **prompt** in the AI Agent to adapt categorization style or tone.  \n- Add a **GitHub commit node** if you want AI-updated metadata written back to files automatically.  \n- Use the **Schedule Trigger** node to automate this process daily.  \n\n---\n\n## Important Notes  \n\n- All API keys and credentials are securely stored — **no hardcoded keys**.  \n- The workflow includes multiple **sticky notes** explaining:  \n  - Repository setup  \n  - File retrieval and AI tagging  \n  - Google Sheet data structure  \n- It uses a **LangChain memory buffer** to improve contextual consistency during multiple analyses.  \n\n---\n\n## Summary  \n\nThis workflow automates metadata management for blogs or documentation sites by combining **GitHub content**, **AI categorization**, and **Google Sheets tracking**.  \nWith it, you can easily maintain consistent tags and categories across dozens of articles — boosting SEO, readability, and editorial efficiency without manual tagging.",
    "features": [],
    "useCases": []
  },
  "logicalBlocks": [],
  "nodeDetails": [
    {
      "name": "AI Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "role": "agent",
      "configDescription": "Version 2.2"
    },
    {
      "name": "Simple Memory",
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "role": "memoryBufferWindow",
      "configDescription": "Version 1.3"
    },
    {
      "name": "OpenAI Chat Model",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "role": "lmChatOpenAi",
      "configDescription": "Version 1.2"
    },
    {
      "name": "List posts/articles/pages",
      "type": "n8n-nodes-base.github",
      "role": "github",
      "configDescription": "Version 1.1"
    },
    {
      "name": "Sticky Note",
      "type": "n8n-nodes-base.stickyNote",
      "role": "stickyNote",
      "configDescription": "Version 1"
    },
    {
      "name": "Sticky Note1",
      "type": "n8n-nodes-base.stickyNote",
      "role": "stickyNote",
      "configDescription": "Version 1"
    },
    {
      "name": "Append rows with posts / article analysis",
      "type": "n8n-nodes-base.googleSheets",
      "role": "googleSheets",
      "configDescription": "Version 4.7"
    },
    {
      "name": "Sticky Note2",
      "type": "n8n-nodes-base.stickyNote",
      "role": "stickyNote",
      "configDescription": "Version 1"
    },
    {
      "name": "Get post/article file",
      "type": "n8n-nodes-base.github",
      "role": "github",
      "configDescription": "Version 1.1"
    },
    {
      "name": "Get row(s) in sheet",
      "type": "n8n-nodes-base.googleSheets",
      "role": "googleSheets",
      "configDescription": "Version 4.7"
    },
    {
      "name": "List FileName only / Remove duplicates",
      "type": "n8n-nodes-base.code",
      "role": "code",
      "configDescription": "Version 2"
    },
    {
      "name": "Get paths to files only from GitHub repository",
      "type": "n8n-nodes-base.aggregate",
      "role": "aggregate",
      "configDescription": "Version 1"
    },
    {
      "name": "Get file paths only  from GoogleSheets",
      "type": "n8n-nodes-base.aggregate",
      "role": "aggregate",
      "configDescription": "Version 1"
    },
    {
      "name": "Check new repo files for AI processing",
      "type": "n8n-nodes-base.code",
      "role": "code",
      "configDescription": "Version 2"
    },
    {
      "name": "Switch",
      "type": "n8n-nodes-base.switch",
      "role": "switch",
      "configDescription": "Version 3.3"
    },
    {
      "name": "On form submission",
      "type": "n8n-nodes-base.formTrigger",
      "role": "formTrigger",
      "configDescription": "Version 2.3"
    },
    {
      "name": "No new posts/articles in GitHub",
      "type": "n8n-nodes-base.form",
      "role": "form",
      "configDescription": "Version 2.3"
    },
    {
      "name": "Proces finished - Categories and tags added",
      "type": "n8n-nodes-base.form",
      "role": "form",
      "configDescription": "Version 2.3"
    },
    {
      "name": "Merge GitHub and Google Sheets read",
      "type": "n8n-nodes-base.merge",
      "role": "merge",
      "configDescription": "Version 3.2"
    },
    {
      "name": "Structured Output Parser",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "role": "outputParserStructured",
      "configDescription": "Version 1.3"
    },
    {
      "name": "Sticky Note3",
      "type": "n8n-nodes-base.stickyNote",
      "role": "stickyNote",
      "configDescription": "Version 1"
    },
    {
      "name": "Sticky Note4",
      "type": "n8n-nodes-base.stickyNote",
      "role": "stickyNote",
      "configDescription": "Version 1"
    },
    {
      "name": "Sticky Note5",
      "type": "n8n-nodes-base.stickyNote",
      "role": "stickyNote",
      "configDescription": "Version 1"
    },
    {
      "name": "Sticky Note6",
      "type": "n8n-nodes-base.stickyNote",
      "role": "stickyNote",
      "configDescription": "Version 1"
    },
    {
      "name": "Sticky Note7",
      "type": "n8n-nodes-base.stickyNote",
      "role": "stickyNote",
      "configDescription": "Version 1"
    },
    {
      "name": "Sticky Note8",
      "type": "n8n-nodes-base.stickyNote",
      "role": "stickyNote",
      "configDescription": "Version 1"
    },
    {
      "name": "Sticky Note9",
      "type": "n8n-nodes-base.stickyNote",
      "role": "stickyNote",
      "configDescription": "Version 1"
    },
    {
      "name": "Loop Over Posts/Pages",
      "type": "n8n-nodes-base.splitInBatches",
      "role": "splitInBatches",
      "configDescription": "Version 3"
    },
    {
      "name": "Sticky Note10",
      "type": "n8n-nodes-base.stickyNote",
      "role": "stickyNote",
      "configDescription": "Version 1"
    }
  ]
}